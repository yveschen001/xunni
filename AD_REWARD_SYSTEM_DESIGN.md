# å»£å‘Šçå‹µç³»çµ±è¨­è¨ˆ

## ğŸ“‹ **éœ€æ±‚åˆ†æ**

### **æ ¸å¿ƒéœ€æ±‚**
1. **å…è²»ç”¨æˆ¶å°ˆå±¬**ï¼šåªæœ‰å…è²»ç”¨æˆ¶å¯ä»¥çœ‹å»£å‘Šå¢åŠ é¡åº¦
2. **è‡¨æ™‚é¡åº¦**ï¼šå»£å‘Šç²å¾—çš„é¡åº¦åªåœ¨ç•¶å¤©æœ‰æ•ˆï¼Œéš”å¤©é‡ç½®
3. **æ¯æ—¥ä¸Šé™**ï¼šæ¯å¤©æœ€å¤šçœ‹ 20 æ¬¡å»£å‘Š
4. **å³æ™‚çå‹µ**ï¼šæ¯æˆåŠŸæ’­æ”¾ä¸€æ¬¡å»£å‘Šï¼Œç«‹å³ +1 é¡åº¦
5. **VIP ä¸å¯ç”¨**ï¼šVIP ç”¨æˆ¶ä¸é¡¯ç¤ºçœ‹å»£å‘Šé¸é …

### **é¡åº¦è¨ˆç®—å…¬å¼**

#### **å…è²»ç”¨æˆ¶**
```typescript
ç•¶æ—¥ç¸½é¡åº¦ = åŸºç¤é¡åº¦(3) + é‚€è«‹çå‹µ(æ°¸ä¹…) + å»£å‘Šçå‹µ(è‡¨æ™‚)
æœ€å¤§é¡åº¦ = 10 + 20 = 30

ä¾‹å¦‚ï¼š
- åŸºç¤ï¼š3 å€‹
- é‚€è«‹æœ‹å‹ï¼š2 å€‹ï¼ˆæ°¸ä¹…ï¼‰
- çœ‹å»£å‘Šï¼š5 å€‹ï¼ˆç•¶å¤©ï¼‰
- ç•¶æ—¥ç¸½é¡åº¦ï¼š10 å€‹
```

#### **VIP ç”¨æˆ¶**
```typescript
ç•¶æ—¥ç¸½é¡åº¦ = åŸºç¤é¡åº¦(30) + é‚€è«‹çå‹µ(æ°¸ä¹…)
æœ€å¤§é¡åº¦ = 100

ç„¡å»£å‘Šé¸é …
```

---

## ğŸ¯ **å»£å‘Šé¡å‹**

### **1. ç¬¬ä¸‰æ–¹è¦–é »å»£å‘Šï¼ˆThird-Party Video Adsï¼‰**
- **æä¾›å•†**ï¼šGigaPubã€Google AdSenseã€Unity Ads
- **ç‰¹é»**ï¼šéœ€è¦è§€çœ‹å®Œæ•´è¦–é »
- **çå‹µ**ï¼šè§€çœ‹å®Œæˆå¾Œ +1 é¡åº¦
- **é™åˆ¶**ï¼šæ¯å¤©æœ€å¤š 20 æ¬¡

### **2. å®˜æ–¹æ–‡å­—å»£å‘Šï¼ˆOfficial Text Adsï¼‰** â­ **æ–°å¢**
- **æä¾›å•†**ï¼šXunNi å®˜æ–¹
- **é¡å‹**ï¼š
  - æ–‡å­—å…¬å‘Šï¼ˆç´”æ–‡å­—ï¼‰
  - éˆæ¥æ¨å»£ï¼ˆå¸¶ URLï¼‰
  - ç¾¤çµ„é‚€è«‹ï¼ˆéœ€åŠ å…¥ç¾¤çµ„ï¼‰
  - é »é“è¨‚é–±ï¼ˆéœ€è¨‚é–±é »é“ï¼‰
- **ç‰¹é»**ï¼š
  - âœ… é»æ“Šå³çå‹µï¼ˆç„¡éœ€ç­‰å¾…ï¼‰
  - âœ… æ¯å€‹å»£å‘Šåªæ¨é€ä¸€æ¬¡çµ¦æ¯å€‹ç”¨æˆ¶
  - âœ… ä¸è¨ˆå…¥æ¯æ—¥ 20 æ¬¡é™åˆ¶
  - âœ… æœªä¾†æ”¯æŒåŠ å…¥ç¾¤çµ„å¾Œèªè­‰
- **çå‹µ**ï¼šé»æ“Šå¾Œç«‹å³ +1 é¡åº¦

---

## ğŸ¯ **å»£å‘Šé›†æˆæ–¹æ¡ˆ**

### **ç¬¬ä¸‰æ–¹å»£å‘Šå¹³å°ï¼šGigaPub**
- **æ–‡æª”**ï¼šhttps://docs.giga.pub/integration-guide.html
- **API**ï¼š`window.showGiga()`
- **ç‰¹é»**ï¼šPromise-basedï¼Œæ”¯æŒçå‹µå›èª¿

### **é›†æˆä»£ç¢¼**
```html
<!-- æ·»åŠ åˆ° HTML head -->
<script src="https://ad.gigapub.tech/script?id=YOUR_PROJECT_ID"></script>

<!-- å¢å¼·å¯é æ€§ç‰ˆæœ¬ï¼ˆæ¨è–¦ï¼‰ -->
<script data-project-id="YOUR_PROJECT_ID">
  !function(){
    var s=document.currentScript,p=s.getAttribute('data-project-id')||'default';
    var d=['https://ad.gigapub.tech','https://ru-ad.gigapub.tech'],i=0,t,sc;
    function l(){
      sc=document.createElement('script');
      sc.async=true;
      sc.src=d[i]+'/script?id='+p;
      clearTimeout(t);
      t=setTimeout(function(){
        sc.onload=sc.onerror=null;
        sc.src='';
        if(++i<d.length)l();
      },15000);
      sc.onload=function(){clearTimeout(t)};
      sc.onerror=function(){clearTimeout(t);if(++i<d.length)l()};
      document.head.appendChild(sc);
    }
    l();
  }();
</script>
```

---

## ğŸ—„ï¸ **æ•¸æ“šåº«è¨­è¨ˆ**

### **1. å»£å‘Šçå‹µè¨˜éŒ„è¡¨ï¼šad_rewards**
```sql
CREATE TABLE IF NOT EXISTS ad_rewards (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  telegram_id TEXT NOT NULL,
  reward_date TEXT NOT NULL,  -- YYYY-MM-DD
  ads_watched INTEGER DEFAULT 0,  -- ç•¶å¤©å·²çœ‹ç¬¬ä¸‰æ–¹å»£å‘Šæ•¸ï¼ˆæœ€å¤š 20ï¼‰
  quota_earned INTEGER DEFAULT 0,  -- ç•¶å¤©ç¬¬ä¸‰æ–¹å»£å‘Šç²å¾—çš„é¡åº¦
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
  
  UNIQUE(telegram_id, reward_date)
);

CREATE INDEX idx_ad_rewards_telegram_date ON ad_rewards(telegram_id, reward_date);
```

### **2. å®˜æ–¹å»£å‘Šè¡¨ï¼šofficial_ads** â­ **æ–°å¢**
```sql
CREATE TABLE IF NOT EXISTS official_ads (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  ad_type TEXT NOT NULL,  -- 'text' | 'link' | 'group' | 'channel'
  title TEXT NOT NULL,  -- å»£å‘Šæ¨™é¡Œ
  content TEXT NOT NULL,  -- å»£å‘Šå…§å®¹
  url TEXT,  -- éˆæ¥ï¼ˆlink/group/channel é¡å‹å¿…å¡«ï¼‰
  target_entity_id TEXT,  -- ç¾¤çµ„/é »é“ IDï¼ˆç”¨æ–¼èªè­‰ï¼‰
  reward_quota INTEGER DEFAULT 1,  -- çå‹µé¡åº¦ï¼ˆé»˜èª 1ï¼‰
  is_enabled INTEGER DEFAULT 1,  -- æ˜¯å¦å•Ÿç”¨
  start_date TEXT,  -- é–‹å§‹æ—¥æœŸï¼ˆå¯é¸ï¼‰
  end_date TEXT,  -- çµæŸæ—¥æœŸï¼ˆå¯é¸ï¼‰
  max_views INTEGER,  -- æœ€å¤§è§€çœ‹æ¬¡æ•¸ï¼ˆå¯é¸ï¼‰
  current_views INTEGER DEFAULT 0,  -- ç•¶å‰è§€çœ‹æ¬¡æ•¸
  requires_verification INTEGER DEFAULT 0,  -- æ˜¯å¦éœ€è¦èªè­‰ï¼ˆç¾¤çµ„/é »é“ï¼‰
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_official_ads_enabled ON official_ads(is_enabled, start_date, end_date);
CREATE INDEX idx_official_ads_type ON official_ads(ad_type);
```

### **3. å®˜æ–¹å»£å‘Šè§€çœ‹è¨˜éŒ„è¡¨ï¼šofficial_ad_views** â­ **æ–°å¢**
```sql
CREATE TABLE IF NOT EXISTS official_ad_views (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  telegram_id TEXT NOT NULL,
  ad_id INTEGER NOT NULL,
  viewed_at TEXT DEFAULT CURRENT_TIMESTAMP,
  clicked INTEGER DEFAULT 0,  -- æ˜¯å¦é»æ“Š
  clicked_at TEXT,  -- é»æ“Šæ™‚é–“
  verified INTEGER DEFAULT 0,  -- æ˜¯å¦å·²èªè­‰ï¼ˆåŠ å…¥ç¾¤çµ„/é »é“ï¼‰
  verified_at TEXT,  -- èªè­‰æ™‚é–“
  reward_granted INTEGER DEFAULT 0,  -- æ˜¯å¦å·²ç™¼æ”¾çå‹µ
  reward_granted_at TEXT,  -- çå‹µç™¼æ”¾æ™‚é–“
  
  UNIQUE(telegram_id, ad_id),
  FOREIGN KEY (ad_id) REFERENCES official_ads(id) ON DELETE CASCADE
);

CREATE INDEX idx_official_ad_views_telegram ON official_ad_views(telegram_id);
CREATE INDEX idx_official_ad_views_ad ON official_ad_views(ad_id);
CREATE INDEX idx_official_ad_views_reward ON official_ad_views(reward_granted);
```

### **å­—æ®µèªªæ˜**

#### **ad_rewards è¡¨**
- `telegram_id`: ç”¨æˆ¶ Telegram ID
- `reward_date`: çå‹µæ—¥æœŸï¼ˆYYYY-MM-DDï¼‰
- `ads_watched`: ç•¶å¤©å·²çœ‹ç¬¬ä¸‰æ–¹å»£å‘Šæ¬¡æ•¸ï¼ˆ0-20ï¼‰
- `quota_earned`: ç•¶å¤©ç¬¬ä¸‰æ–¹å»£å‘Šç²å¾—çš„é¡åº¦ï¼ˆ0-20ï¼‰

#### **official_ads è¡¨**
- `ad_type`: å»£å‘Šé¡å‹ï¼ˆtext/link/group/channelï¼‰
- `title`: å»£å‘Šæ¨™é¡Œ
- `content`: å»£å‘Šå…§å®¹ï¼ˆæ”¯æŒ Markdownï¼‰
- `url`: éˆæ¥åœ°å€ï¼ˆlink/group/channel é¡å‹å¿…å¡«ï¼‰
- `target_entity_id`: ç›®æ¨™ç¾¤çµ„/é »é“ IDï¼ˆç”¨æ–¼æ©Ÿå™¨äººèªè­‰ï¼‰
- `reward_quota`: çå‹µé¡åº¦ï¼ˆé»˜èª 1ï¼Œå¯è¨­ç½®æ›´é«˜ï¼‰
- `requires_verification`: æ˜¯å¦éœ€è¦èªè­‰ï¼ˆç¾¤çµ„/é »é“åŠ å…¥å¾Œæ‰ç™¼æ”¾çå‹µï¼‰
- `max_views`: æœ€å¤§è§€çœ‹æ¬¡æ•¸é™åˆ¶ï¼ˆé”åˆ°å¾Œè‡ªå‹•åœç”¨ï¼‰

#### **official_ad_views è¡¨**
- `telegram_id`: ç”¨æˆ¶ Telegram ID
- `ad_id`: å»£å‘Š ID
- `clicked`: æ˜¯å¦é»æ“Šï¼ˆ0/1ï¼‰
- `verified`: æ˜¯å¦å·²èªè­‰ï¼ˆ0/1ï¼Œåƒ…ç¾¤çµ„/é »é“é¡å‹ï¼‰
- `reward_granted`: æ˜¯å¦å·²ç™¼æ”¾çå‹µï¼ˆ0/1ï¼‰

---

## ğŸ“Š **Domain é‚è¼¯**

### **æ–‡ä»¶ï¼š`src/domain/ad_reward.ts`**ï¼ˆæ–°å»ºï¼‰

```typescript
/**
 * Ad Reward Domain Logic
 * Manages daily ad watching and quota rewards
 */

export interface AdReward {
  id: number;
  telegram_id: string;
  reward_date: string;
  ads_watched: number;
  quota_earned: number;
  created_at: string;
  updated_at: string;
}

// Constants
export const MAX_DAILY_ADS = 20;
export const QUOTA_PER_AD = 1;
export const AD_COOLDOWN_HOURS = 24;

/**
 * Check if user can watch ad today
 */
export function canWatchAd(adsWatched: number): boolean {
  return adsWatched < MAX_DAILY_ADS;
}

/**
 * Get remaining ads for today
 */
export function getRemainingAds(adsWatched: number): number {
  return Math.max(0, MAX_DAILY_ADS - adsWatched);
}

/**
 * Calculate hours until next ad reset
 */
export function getHoursUntilReset(): number {
  const now = new Date();
  const tomorrow = new Date(now);
  tomorrow.setDate(tomorrow.getDate() + 1);
  tomorrow.setHours(0, 0, 0, 0);
  
  const diffMs = tomorrow.getTime() - now.getTime();
  const diffHours = Math.ceil(diffMs / (1000 * 60 * 60));
  
  return diffHours;
}

/**
 * Get today's date string (YYYY-MM-DD)
 */
export function getTodayDateString(): string {
  const now = new Date();
  return now.toISOString().split('T')[0];
}

/**
 * Calculate total daily quota including ad rewards
 */
export function calculateDailyQuotaWithAds(
  baseQuota: number,
  inviteBonus: number,
  adBonus: number
): number {
  // Free user max: 10 (base+invite) + 20 (ads) = 30
  const maxBaseQuota = 10;
  const baseWithInvite = Math.min(baseQuota + inviteBonus, maxBaseQuota);
  
  return baseWithInvite + adBonus;
}
```

---

## ğŸ”§ **æ•¸æ“šåº«æŸ¥è©¢**

### **æ–‡ä»¶ï¼š`src/db/queries/ad_rewards.ts`**ï¼ˆæ–°å»ºï¼‰

```typescript
/**
 * Ad Rewards Database Queries
 */

import type { DatabaseClient } from '../client';
import type { AdReward } from '~/domain/ad_reward';
import { getTodayDateString } from '~/domain/ad_reward';

/**
 * Get today's ad reward record for user
 */
export async function getTodayAdReward(
  db: DatabaseClient,
  telegramId: string
): Promise<AdReward | null> {
  const today = getTodayDateString();
  
  const result = await db.d1
    .prepare(
      `SELECT * FROM ad_rewards 
       WHERE telegram_id = ? AND reward_date = ?`
    )
    .bind(telegramId, today)
    .first<AdReward>();
  
  return result || null;
}

/**
 * Create or get today's ad reward record
 */
export async function getOrCreateTodayAdReward(
  db: DatabaseClient,
  telegramId: string
): Promise<AdReward> {
  const existing = await getTodayAdReward(db, telegramId);
  if (existing) {
    return existing;
  }
  
  const today = getTodayDateString();
  
  await db.d1
    .prepare(
      `INSERT INTO ad_rewards (telegram_id, reward_date, ads_watched, quota_earned)
       VALUES (?, ?, 0, 0)`
    )
    .bind(telegramId, today)
    .run();
  
  const created = await getTodayAdReward(db, telegramId);
  if (!created) {
    throw new Error('Failed to create ad reward record');
  }
  
  return created;
}

/**
 * Increment ad watch count and quota
 */
export async function incrementAdReward(
  db: DatabaseClient,
  telegramId: string
): Promise<AdReward> {
  const today = getTodayDateString();
  
  await db.d1
    .prepare(
      `UPDATE ad_rewards 
       SET ads_watched = ads_watched + 1,
           quota_earned = quota_earned + 1,
           updated_at = CURRENT_TIMESTAMP
       WHERE telegram_id = ? AND reward_date = ?`
    )
    .bind(telegramId, today)
    .run();
  
  const updated = await getTodayAdReward(db, telegramId);
  if (!updated) {
    throw new Error('Failed to update ad reward');
  }
  
  return updated;
}
```

---

## ğŸ¨ **æç¤ºè¨Šæ¯å„ªåŒ–**

### **æ›´æ–°ï¼š`src/domain/bottle_quota_prompt.ts`**

```typescript
/**
 * Generate quota exhausted prompt with ad option
 */
export function getQuotaExhaustedPrompt(
  isVip: boolean,
  throwsToday: number,
  quota: number,
  maxQuota: number,
  adsWatched: number = 0  // âœ¨ NEW: ç•¶å¤©å·²çœ‹å»£å‘Šæ•¸
): QuotaPromptResult {
  // Free user - quota not full (3-9)
  if (!isVip && quota < 10) {
    const remainingAds = MAX_DAILY_ADS - adsWatched;
    const adOption = remainingAds > 0
      ? `\n\nğŸ“º æˆ–è€…çœ‹å»£å‘Šå¢åŠ é¡åº¦ï¼š\n` +
        `â€¢ æ¯çœ‹ä¸€å‰‡å»£å‘Š +1 é¡åº¦\n` +
        `â€¢ ä»Šæ—¥å‰©é¤˜ï¼š${remainingAds}/20 æ¬¡\n` +
        `â€¢ é¡åº¦æ˜å¤©é‡ç½®`
      : `\n\nğŸ“º ä»Šæ—¥å»£å‘Šå·²çœ‹å®Œï¼ˆ20/20ï¼‰\n` +
        `â€¢ é è¨ˆ ${getHoursUntilReset()} å°æ™‚å¾Œé‡ç½®`;
    
    return {
      message:
        `âŒ ä»Šæ—¥æ¼‚æµç“¶é…é¡å·²ç”¨å®Œï¼ˆ${throwsToday}/${quota}ï¼‰\n\n` +
        `ğŸ’¡ æƒ³è¦æ›´å¤šé…é¡å—ï¼Ÿ\n\n` +
        `ğŸ é‚€è«‹æœ‹å‹ä¸€èµ·ç©ï¼š\n` +
        `â€¢ æ¯ä½æœ‹å‹æˆåŠŸé€å‡ºæ¼‚æµç“¶\n` +
        `â€¢ ä½ å¯ç²å¾— +1 é…é¡ï¼ˆæ°¸ä¹…ï¼‰\n` +
        `â€¢ æœ€å¤šå¯å¢åŠ åˆ° 10 å€‹/å¤©` +
        adOption +
        `\n\næˆ–è€…å‡ç´š VIP ç²å¾— 30+ é…é¡ï¼š/vip`,
      buttons: [
        [{ text: 'ğŸ“² é‚€è«‹æœ‹å‹', callback_data: 'show_invite' }],
        ...(remainingAds > 0 
          ? [[{ text: 'ğŸ“º çœ‹å»£å‘Š +1', callback_data: 'watch_ad' }]]
          : []
        ),
      ],
    };
  }

  // Free user - quota full (10)
  if (!isVip && quota >= 10) {
    const remainingAds = MAX_DAILY_ADS - adsWatched;
    const adOption = remainingAds > 0
      ? {
          message: `\n\nğŸ“º é‚„å¯ä»¥çœ‹å»£å‘Šå¢åŠ é¡åº¦ï¼š\n` +
                   `â€¢ æ¯çœ‹ä¸€å‰‡å»£å‘Š +1 é¡åº¦\n` +
                   `â€¢ ä»Šæ—¥å‰©é¤˜ï¼š${remainingAds}/20 æ¬¡`,
          button: [{ text: 'ğŸ“º çœ‹å»£å‘Š +1', callback_data: 'watch_ad' }]
        }
      : {
          message: `\n\nğŸ“º ä»Šæ—¥å»£å‘Šå·²çœ‹å®Œï¼ˆ20/20ï¼‰\n` +
                   `â€¢ é è¨ˆ ${getHoursUntilReset()} å°æ™‚å¾Œé‡ç½®`,
          button: null
        };
    
    return {
      message:
        `âŒ ä»Šæ—¥æ¼‚æµç“¶é…é¡å·²ç”¨å®Œï¼ˆ${throwsToday}/${quota}ï¼‰\n\n` +
        `ğŸŒŸ å·²é”å…è²»ç”¨æˆ¶åŸºç¤æœ€å¤§é…é¡ï¼` +
        adOption.message +
        `\n\næƒ³è¦æ›´å¤šé…é¡ï¼Ÿå‡ç´š VIPï¼š\n` +
        `â€¢ åŸºç¤é…é¡ï¼š30 å€‹/å¤©\n` +
        `â€¢ é‚€è«‹çå‹µï¼šæœ€å¤š 100 å€‹/å¤©\n` +
        `â€¢ ç„¡éœ€çœ‹å»£å‘Š`,
      buttons: [
        ...(adOption.button ? [[adOption.button]] : []),
        [{ text: 'ğŸ’ ç«‹å³å‡ç´š VIP', callback_data: 'show_vip' }],
      ],
    };
  }

  // VIP user - no ad option
  // ... (ä¿æŒåŸæœ‰ VIP é‚è¼¯)
}
```

---

## ğŸ¬ **å»£å‘Šè™•ç†å™¨**

### **æ–‡ä»¶ï¼š`src/telegram/handlers/ad_reward.ts`**ï¼ˆæ–°å»ºï¼‰

```typescript
/**
 * Ad Reward Handler
 * Handles ad watching and quota rewards
 */

import type { Env, CallbackQuery } from '~/types';
import { createDatabaseClient } from '~/db/client';
import { createTelegramService } from '~/services/telegram';
import { findUserByTelegramId } from '~/db/queries/users';
import { getOrCreateTodayAdReward, incrementAdReward } from '~/db/queries/ad_rewards';
import { canWatchAd, getRemainingAds, getHoursUntilReset } from '~/domain/ad_reward';

/**
 * Handle watch ad callback
 */
export async function handleWatchAd(
  callbackQuery: CallbackQuery,
  env: Env
): Promise<void> {
  const telegram = createTelegramService(env);
  const db = createDatabaseClient(env.DB);
  const chatId = callbackQuery.message!.chat.id;
  const telegramId = callbackQuery.from.id.toString();

  try {
    // Get user
    const user = await findUserByTelegramId(db, telegramId);
    if (!user) {
      await telegram.answerCallbackQuery(callbackQuery.id, 'âŒ ç”¨æˆ¶ä¸å­˜åœ¨');
      return;
    }

    // Check if VIP (VIP users cannot watch ads)
    const isVip = !!(user.is_vip && user.vip_expire_at && new Date(user.vip_expire_at) > new Date());
    if (isVip) {
      await telegram.answerCallbackQuery(callbackQuery.id, 'âŒ VIP ç”¨æˆ¶ç„¡éœ€çœ‹å»£å‘Š');
      await telegram.sendMessage(
        chatId,
        'ğŸ’ VIP ç”¨æˆ¶å·²äº«æœ‰å……è¶³é…é¡ï¼Œç„¡éœ€çœ‹å»£å‘Šï¼\n\n' +
        'æŸ¥çœ‹ä½ çš„é…é¡ï¼š/profile'
      );
      return;
    }

    // Get today's ad reward record
    const adReward = await getOrCreateTodayAdReward(db, telegramId);

    // Check if can watch more ads today
    if (!canWatchAd(adReward.ads_watched)) {
      const hoursUntilReset = getHoursUntilReset();
      await telegram.answerCallbackQuery(
        callbackQuery.id,
        `âŒ ä»Šæ—¥å»£å‘Šå·²çœ‹å®Œï¼ˆ20/20ï¼‰`
      );
      await telegram.sendMessage(
        chatId,
        `ğŸ“º ä»Šæ—¥å»£å‘Šé…é¡å·²ç”¨å®Œ\n\n` +
        `â€¢ å·²è§€çœ‹ï¼š20/20 æ¬¡\n` +
        `â€¢ é è¨ˆ ${hoursUntilReset} å°æ™‚å¾Œé‡ç½®\n\n` +
        `ğŸ’¡ ä½ é‚„å¯ä»¥ï¼š\n` +
        `â€¢ é‚€è«‹æœ‹å‹ç²å¾—æ°¸ä¹…é¡åº¦ï¼š/profile\n` +
        `â€¢ å‡ç´š VIP ç„¡é™æš¢ç©ï¼š/vip`
      );
      return;
    }

    // Answer callback first
    await telegram.answerCallbackQuery(callbackQuery.id, 'ğŸ“º æ­£åœ¨åŠ è¼‰å»£å‘Š...');

    // Send loading message
    const loadingMsg = await telegram.sendMessage(
      chatId,
      'ğŸ“º æ­£åœ¨ç‚ºä½ æº–å‚™å»£å‘Š...\n\n' +
      'è«‹ç¨å€™ï¼Œå»£å‘ŠåŠ è¼‰ä¸­...'
    );

    // Trigger ad display via Telegram Mini App
    // Note: This requires Telegram Mini App integration
    // For now, we'll simulate the ad watch process
    
    // TODO: Integrate with GigaPub via Telegram Mini App
    // The actual implementation will need:
    // 1. A web page hosted on your domain
    // 2. The page includes GigaPub script
    // 3. Open the page in Telegram Mini App
    // 4. Call window.showGiga()
    // 5. On success, call your webhook to increment quota

    // For now, send instructions to user
    await telegram.editMessageText(
      chatId,
      loadingMsg.message_id,
      'ğŸ“º **è§€çœ‹å»£å‘Šç²å¾—é¡åº¦**\n\n' +
      'é»æ“Šä¸‹æ–¹æŒ‰éˆ•é–‹å§‹è§€çœ‹å»£å‘Šï¼š',
      [
        [
          {
            text: 'â–¶ï¸ é–‹å§‹è§€çœ‹å»£å‘Š',
            url: `https://your-domain.com/ad?user=${telegramId}&token=${generateAdToken(telegramId, env)}`
          }
        ],
        [
          { text: 'âŒ å–æ¶ˆ', callback_data: 'cancel_ad' }
        ]
      ]
    );

  } catch (error) {
    console.error('[handleWatchAd] Error:', error);
    await telegram.answerCallbackQuery(
      callbackQuery.id,
      'âŒ åŠ è¼‰å»£å‘Šå¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦'
    );
  }
}

/**
 * Handle ad completion webhook
 * Called by your ad page after successful ad watch
 */
export async function handleAdComplete(
  telegramId: string,
  token: string,
  env: Env
): Promise<{ success: boolean; message: string }> {
  const db = createDatabaseClient(env.DB);

  try {
    // Verify token
    if (!verifyAdToken(telegramId, token, env)) {
      return { success: false, message: 'Invalid token' };
    }

    // Get user
    const user = await findUserByTelegramId(db, telegramId);
    if (!user) {
      return { success: false, message: 'User not found' };
    }

    // Check if VIP
    const isVip = !!(user.is_vip && user.vip_expire_at && new Date(user.vip_expire_at) > new Date());
    if (isVip) {
      return { success: false, message: 'VIP users cannot watch ads' };
    }

    // Get today's ad reward
    const adReward = await getOrCreateTodayAdReward(db, telegramId);

    // Check if can watch more ads
    if (!canWatchAd(adReward.ads_watched)) {
      return { success: false, message: 'Daily ad limit reached' };
    }

    // Increment ad reward
    const updated = await incrementAdReward(db, telegramId);

    // Send success notification
    const telegram = createTelegramService(env);
    const remaining = getRemainingAds(updated.ads_watched);
    
    await telegram.sendMessage(
      parseInt(telegramId),
      `âœ… å»£å‘Šè§€çœ‹æˆåŠŸï¼\n\n` +
      `ğŸ ä½ ç²å¾—äº† +1 æ¼‚æµç“¶é¡åº¦\n` +
      `ğŸ“Š ä»Šæ—¥å»£å‘Šï¼š${updated.ads_watched}/20\n` +
      `ğŸ“º å‰©é¤˜æ¬¡æ•¸ï¼š${remaining} æ¬¡\n\n` +
      `ç¾åœ¨å¯ä»¥ç¹¼çºŒä¸Ÿç“¶å­äº†ï¼š/throw`
    );

    return {
      success: true,
      message: 'Ad reward granted successfully'
    };

  } catch (error) {
    console.error('[handleAdComplete] Error:', error);
    return {
      success: false,
      message: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

/**
 * Generate ad token for verification
 */
function generateAdToken(telegramId: string, env: Env): string {
  // Simple token generation (you should use a more secure method in production)
  const secret = env.BOT_TOKEN || 'default-secret';
  const timestamp = Date.now();
  const data = `${telegramId}:${timestamp}`;
  
  // In production, use proper HMAC or JWT
  return Buffer.from(data).toString('base64');
}

/**
 * Verify ad token
 */
function verifyAdToken(telegramId: string, token: string, env: Env): boolean {
  try {
    const decoded = Buffer.from(token, 'base64').toString('utf-8');
    const [id, timestamp] = decoded.split(':');
    
    // Check if token is for this user
    if (id !== telegramId) {
      return false;
    }
    
    // Check if token is not expired (5 minutes)
    const now = Date.now();
    const tokenTime = parseInt(timestamp);
    if (now - tokenTime > 5 * 60 * 1000) {
      return false;
    }
    
    return true;
  } catch {
    return false;
  }
}
```

---

## ğŸŒ **å»£å‘Šé é¢å¯¦ç¾**

### **æ–‡ä»¶ï¼š`public/ad.html`**ï¼ˆæ–°å»ºï¼‰

```html
<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>è§€çœ‹å»£å‘Š - XunNi</title>
  
  <!-- GigaPub Enhanced Script -->
  <script data-project-id="YOUR_PROJECT_ID">
    !function(){
      var s=document.currentScript,p=s.getAttribute('data-project-id')||'default';
      var d=['https://ad.gigapub.tech','https://ru-ad.gigapub.tech'],i=0,t,sc;
      function l(){
        sc=document.createElement('script');
        sc.async=true;
        sc.src=d[i]+'/script?id='+p;
        clearTimeout(t);
        t=setTimeout(function(){
          sc.onload=sc.onerror=null;
          sc.src='';
          if(++i<d.length)l();
        },15000);
        sc.onload=function(){clearTimeout(t)};
        sc.onerror=function(){clearTimeout(t);if(++i<d.length)l()};
        document.head.appendChild(sc);
      }
      l();
    }();
  </script>
  
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }
    .container {
      text-align: center;
      max-width: 400px;
    }
    .icon {
      font-size: 64px;
      margin-bottom: 20px;
    }
    h1 {
      font-size: 24px;
      margin-bottom: 10px;
    }
    p {
      font-size: 16px;
      opacity: 0.9;
      margin-bottom: 30px;
    }
    button {
      background: white;
      color: #667eea;
      border: none;
      padding: 15px 40px;
      font-size: 18px;
      font-weight: bold;
      border-radius: 25px;
      cursor: pointer;
      transition: transform 0.2s;
    }
    button:hover {
      transform: scale(1.05);
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .status {
      margin-top: 20px;
      font-size: 14px;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="icon">ğŸ“º</div>
    <h1>è§€çœ‹å»£å‘Šç²å¾—é¡åº¦</h1>
    <p>è§€çœ‹å®Œæ•´å»£å‘Šå¾Œï¼Œä½ å°‡ç²å¾— +1 æ¼‚æµç“¶é¡åº¦</p>
    <button id="watchBtn" onclick="watchAd()">â–¶ï¸ é–‹å§‹è§€çœ‹</button>
    <div id="status" class="status"></div>
  </div>

  <script>
    // Get URL parameters
    const params = new URLSearchParams(window.location.search);
    const userId = params.get('user');
    const token = params.get('token');

    if (!userId || !token) {
      document.getElementById('status').textContent = 'âŒ ç„¡æ•ˆçš„éˆæ¥';
      document.getElementById('watchBtn').disabled = true;
    }

    async function watchAd() {
      const btn = document.getElementById('watchBtn');
      const status = document.getElementById('status');
      
      btn.disabled = true;
      status.textContent = 'ğŸ“º æ­£åœ¨åŠ è¼‰å»£å‘Š...';

      try {
        // Check if showGiga is available
        if (typeof window.showGiga !== 'function') {
          throw new Error('å»£å‘Šæœå‹™æœªå°±ç·’ï¼Œè«‹ç¨å¾Œå†è©¦');
        }

        // Show ad
        await window.showGiga();
        
        // Ad completed successfully
        status.textContent = 'âœ… å»£å‘Šæ’­æ”¾å®Œæˆï¼Œæ­£åœ¨ç™¼æ”¾çå‹µ...';
        
        // Notify backend
        const response = await fetch('/api/ad-complete', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            user_id: userId,
            token: token,
          }),
        });

        const result = await response.json();
        
        if (result.success) {
          status.textContent = 'ğŸ‰ æ­å–œï¼ä½ ç²å¾—äº† +1 é¡åº¦';
          setTimeout(() => {
            if (window.Telegram && window.Telegram.WebApp) {
              window.Telegram.WebApp.close();
            } else {
              window.close();
            }
          }, 2000);
        } else {
          throw new Error(result.message || 'çå‹µç™¼æ”¾å¤±æ•—');
        }

      } catch (error) {
        console.error('Ad error:', error);
        status.textContent = `âŒ ${error.message || 'å»£å‘Šæ’­æ”¾å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦'}`;
        btn.disabled = false;
      }
    }
  </script>
</body>
</html>
```

---

## ğŸ”Œ **Router é›†æˆ**

### **æ›´æ–°ï¼š`src/router.ts`**

```typescript
// Watch ad callback
if (callbackData === 'watch_ad') {
  const { handleWatchAd } = await import('./telegram/handlers/ad_reward');
  await handleWatchAd(callbackQuery, env);
  return;
}

// Cancel ad callback
if (callbackData === 'cancel_ad') {
  await telegram.answerCallbackQuery(callbackQuery.id, 'å·²å–æ¶ˆ');
  await telegram.deleteMessage(
    callbackQuery.message!.chat.id,
    callbackQuery.message!.message_id
  );
  return;
}
```

### **æ·»åŠ  API ç«¯é»**

```typescript
// Handle ad completion webhook
if (url.pathname === '/api/ad-complete') {
  if (request.method !== 'POST') {
    return new Response('Method not allowed', { status: 405 });
  }

  try {
    const body = await request.json() as { user_id: string; token: string };
    const { handleAdComplete } = await import('./telegram/handlers/ad_reward');
    const result = await handleAdComplete(body.user_id, body.token, env);
    
    return new Response(JSON.stringify(result), {
      headers: { 'Content-Type': 'application/json' },
    });
  } catch (error) {
    return new Response(
      JSON.stringify({ success: false, message: 'Internal server error' }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
}
```

---

## ğŸ”„ **é¡åº¦è¨ˆç®—æ›´æ–°**

### **æ›´æ–°ï¼š`src/domain/bottle.ts`**

```typescript
/**
 * Get bottle quota including ad rewards
 */
export function getBottleQuotaWithAds(
  isVip: boolean,
  inviteBonus: number,
  adBonus: number = 0  // âœ¨ NEW: Ad reward bonus
): {
  quota: number;
  maxQuota: number;
} {
  if (isVip) {
    // VIP: no ad bonus
    const baseQuota = 30;
    const maxQuota = 100;
    const quota = Math.min(baseQuota + inviteBonus, maxQuota);
    return { quota, maxQuota };
  } else {
    // Free: base + invite (max 10) + ad (max 20)
    const baseQuota = 3;
    const maxInviteQuota = 10;
    const maxAdQuota = 20;
    
    const baseWithInvite = Math.min(baseQuota + inviteBonus, maxInviteQuota);
    const quota = baseWithInvite + Math.min(adBonus, maxAdQuota);
    const maxQuota = maxInviteQuota + maxAdQuota; // 30
    
    return { quota, maxQuota };
  }
}
```

---

## ğŸ“ **Migration è…³æœ¬**

### **æ–‡ä»¶ï¼š`src/db/migrations/0022_create_ad_rewards_table.sql`**

```sql
-- Migration: 0022_create_ad_rewards_table.sql
-- Create ad_rewards table for daily ad watching rewards

CREATE TABLE IF NOT EXISTS ad_rewards (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  telegram_id TEXT NOT NULL,
  reward_date TEXT NOT NULL,  -- YYYY-MM-DD
  ads_watched INTEGER DEFAULT 0,  -- ç•¶å¤©å·²çœ‹å»£å‘Šæ•¸ (0-20)
  quota_earned INTEGER DEFAULT 0,  -- ç•¶å¤©å»£å‘Šç²å¾—çš„é¡åº¦ (0-20)
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
  
  UNIQUE(telegram_id, reward_date)
);

CREATE INDEX IF NOT EXISTS idx_ad_rewards_telegram_date 
  ON ad_rewards(telegram_id, reward_date);

CREATE INDEX IF NOT EXISTS idx_ad_rewards_date 
  ON ad_rewards(reward_date);
```

---

## âœ… **å¯¦ç¾æª¢æŸ¥æ¸…å–®**

### **Phase 1: æ•¸æ“šåº« & Domain**
- [ ] å‰µå»º Migration `0022_create_ad_rewards_table.sql`
- [ ] åŸ·è¡Œ Migration
- [ ] å‰µå»º `src/domain/ad_reward.ts`
- [ ] å‰µå»º `src/db/queries/ad_rewards.ts`
- [ ] æ›´æ–° `src/domain/bottle.ts` æ·»åŠ  `getBottleQuotaWithAds()`

### **Phase 2: æç¤ºå„ªåŒ–**
- [ ] æ›´æ–° `src/domain/bottle_quota_prompt.ts`
- [ ] æ·»åŠ å»£å‘Šé¸é …åˆ°æç¤ºè¨Šæ¯
- [ ] æ›´æ–° `src/telegram/handlers/throw.ts`

### **Phase 3: å»£å‘Šè™•ç†**
- [ ] å‰µå»º `src/telegram/handlers/ad_reward.ts`
- [ ] æ›´æ–° `src/router.ts` æ·»åŠ  callback è™•ç†
- [ ] æ›´æ–° `src/router.ts` æ·»åŠ  API ç«¯é»

### **Phase 4: å‰ç«¯é é¢**
- [ ] å‰µå»º `public/ad.html`
- [ ] é…ç½® GigaPub Project ID
- [ ] æ¸¬è©¦å»£å‘Šæ’­æ”¾æµç¨‹

### **Phase 5: æ¸¬è©¦**
- [ ] æ¸¬è©¦å…è²»ç”¨æˆ¶çœ‹å»£å‘Šæµç¨‹
- [ ] æ¸¬è©¦æ¯æ—¥ä¸Šé™ï¼ˆ20 æ¬¡ï¼‰
- [ ] æ¸¬è©¦éš”å¤©é‡ç½®
- [ ] æ¸¬è©¦ VIP ç”¨æˆ¶ç„¡å»£å‘Šé¸é …
- [ ] æ¸¬è©¦é¡åº¦è¨ˆç®—æ­£ç¢ºæ€§

---

## ğŸ¯ **ç”¨æˆ¶é«”é©—æµç¨‹**

### **å…è²»ç”¨æˆ¶çœ‹å»£å‘Š**
```
1. ç”¨æˆ¶ï¼š/throwï¼ˆé¡åº¦å·²ç”¨å®Œï¼‰
   â†“
2. Botï¼šé¡¯ç¤ºé¡åº¦ç”¨å®Œæç¤º
   â€¢ é‚€è«‹æœ‹å‹ï¼ˆæ°¸ä¹…ï¼‰
   â€¢ çœ‹å»£å‘Š +1ï¼ˆç•¶å¤©ï¼‰
   â€¢ å‡ç´š VIP
   [ğŸ“² é‚€è«‹æœ‹å‹] [ğŸ“º çœ‹å»£å‘Š +1]
   â†“
3. ç”¨æˆ¶ï¼šé»æ“Š [ğŸ“º çœ‹å»£å‘Š +1]
   â†“
4. Botï¼šæ‰“é–‹å»£å‘Šé é¢ï¼ˆTelegram Mini Appï¼‰
   â†“
5. ç”¨æˆ¶ï¼šè§€çœ‹å®Œæ•´å»£å‘Š
   â†“
6. å»£å‘Šé é¢ï¼šèª¿ç”¨ window.showGiga()
   â†“
7. å»£å‘Šå®Œæˆï¼šé€šçŸ¥å¾Œç«¯ /api/ad-complete
   â†“
8. å¾Œç«¯ï¼š+1 é¡åº¦ï¼Œç™¼é€æˆåŠŸé€šçŸ¥
   â†“
9. Botï¼šâœ… ä½ ç²å¾—äº† +1 é¡åº¦ï¼
   ç¾åœ¨å¯ä»¥ç¹¼çºŒä¸Ÿç“¶å­äº†ï¼š/throw
```

---

## ğŸ›¡ï¸ **å®‰å…¨è€ƒæ…®**

### **1. Token é©—è­‰**
- âœ… æ¯å€‹å»£å‘Šéˆæ¥åŒ…å«å”¯ä¸€ token
- âœ… Token æœ‰æ•ˆæœŸ 5 åˆ†é˜
- âœ… Token ç¶å®šç‰¹å®šç”¨æˆ¶

### **2. é˜²åˆ·æ©Ÿåˆ¶**
- âœ… æ¯æ—¥ä¸Šé™ 20 æ¬¡
- âœ… æ•¸æ“šåº«å”¯ä¸€ç´„æŸï¼ˆtelegram_id + reward_dateï¼‰
- âœ… å¾Œç«¯é©—è­‰ç”¨æˆ¶èº«ä»½

### **3. VIP ä¿è­·**
- âœ… VIP ç”¨æˆ¶ç„¡æ³•çœ‹å»£å‘Š
- âœ… å‰ç«¯å’Œå¾Œç«¯é›™é‡æª¢æŸ¥

---

## ğŸ“Š **é æœŸæ•ˆæœ**

### **ç”¨æˆ¶å¢é•·**
- âœ… æä¾›å…è²»ç”¨æˆ¶æ›´å¤šé¸æ“‡
- âœ… é™ä½ VIP è³¼è²·å£“åŠ›
- âœ… æé«˜ç”¨æˆ¶ç•™å­˜ç‡

### **æ”¶ç›Šå¹³è¡¡**
- âœ… å»£å‘Šæ”¶å…¥è£œå……
- âœ… ä¿æŒ VIP å¸å¼•åŠ›ï¼ˆç„¡å»£å‘Šï¼‰
- âœ… é¼“å‹µé‚€è«‹æ©Ÿåˆ¶ï¼ˆæ°¸ä¹…é¡åº¦ï¼‰

---

## ğŸš€ **éƒ¨ç½²æ­¥é©Ÿ**

1. âœ… åŸ·è¡Œæ•¸æ“šåº« Migration
2. âœ… éƒ¨ç½²å¾Œç«¯ä»£ç¢¼
3. âœ… éƒ¨ç½²å»£å‘Šé é¢ï¼ˆpublic/ad.htmlï¼‰
4. âœ… é…ç½® GigaPub Project ID
5. âœ… æ¸¬è©¦å®Œæ•´æµç¨‹
6. âœ… ç›£æ§å»£å‘Šæ’­æ”¾æ•¸æ“š

---

**è¨­è¨ˆå®Œæˆï¼æº–å‚™å¯¦ç¾ï¼** ğŸ‰

**åƒè€ƒæ–‡æª”ï¼š**
- GigaPub Integration: https://docs.giga.pub/integration-guide.html
- Telegram Mini Apps: https://core.telegram.org/bots/webapps

---

## ğŸ“Š **å»£å‘Šçµ±è¨ˆç³»çµ±**

### **éœ€æ±‚**
- çµ±è¨ˆå»£å‘Šè¢«è§€çœ‹æ¬¡æ•¸ï¼ˆad_viewsï¼‰
- çµ±è¨ˆå»£å‘ŠæˆåŠŸæ’­æ”¾æ¬¡æ•¸ï¼ˆad_completionsï¼‰
- æ¯æ—¥çµ±è¨ˆå ±è¡¨æ¨é€çµ¦è¶…ç´šç®¡ç†å“¡
- é›†æˆåˆ°ç¾æœ‰çš„ daily_stats ç³»çµ±

---

### **æ•¸æ“šåº«è¨­è¨ˆ**

#### **æ›´æ–° ad_rewards è¡¨**
```sql
-- æ·»åŠ çµ±è¨ˆå­—æ®µ
ALTER TABLE ad_rewards ADD COLUMN ad_views INTEGER DEFAULT 0;  -- å»£å‘Šé–‹å§‹æ’­æ”¾æ¬¡æ•¸
ALTER TABLE ad_rewards ADD COLUMN ad_completions INTEGER DEFAULT 0;  -- å»£å‘Šå®Œæ•´æ’­æ”¾æ¬¡æ•¸
```

#### **æ›´æ–° daily_stats è¡¨**
```sql
-- æ·»åŠ å»£å‘Šçµ±è¨ˆå­—æ®µåˆ° daily_stats
ALTER TABLE daily_stats ADD COLUMN total_ad_views INTEGER DEFAULT 0;  -- ç•¶æ—¥å»£å‘Šè§€çœ‹æ¬¡æ•¸
ALTER TABLE daily_stats ADD COLUMN total_ad_completions INTEGER DEFAULT 0;  -- ç•¶æ—¥å»£å‘Šå®Œæˆæ¬¡æ•¸
ALTER TABLE daily_stats ADD COLUMN ad_completion_rate REAL DEFAULT 0.0;  -- å»£å‘Šå®Œæˆç‡
ALTER TABLE daily_stats ADD COLUMN total_ad_quota_earned INTEGER DEFAULT 0;  -- å»£å‘Šç²å¾—çš„ç¸½é¡åº¦
```

---

### **Migration è…³æœ¬**

#### **æ–‡ä»¶ï¼š`src/db/migrations/0023_add_ad_statistics.sql`**

```sql
-- Migration: 0023_add_ad_statistics.sql
-- Add ad statistics tracking to ad_rewards and daily_stats tables

-- Add statistics to ad_rewards table
ALTER TABLE ad_rewards ADD COLUMN ad_views INTEGER DEFAULT 0;
ALTER TABLE ad_rewards ADD COLUMN ad_completions INTEGER DEFAULT 0;

-- Add ad statistics to daily_stats table
ALTER TABLE daily_stats ADD COLUMN total_ad_views INTEGER DEFAULT 0;
ALTER TABLE daily_stats ADD COLUMN total_ad_completions INTEGER DEFAULT 0;
ALTER TABLE daily_stats ADD COLUMN ad_completion_rate REAL DEFAULT 0.0;
ALTER TABLE daily_stats ADD COLUMN total_ad_quota_earned INTEGER DEFAULT 0;
```

---

### **Domain é‚è¼¯æ›´æ–°**

#### **æ›´æ–°ï¼š`src/domain/ad_reward.ts`**

```typescript
/**
 * Calculate ad completion rate
 */
export function calculateAdCompletionRate(
  completions: number,
  views: number
): number {
  if (views === 0) return 0;
  return Math.round((completions / views) * 100 * 100) / 100; // ä¿ç•™å…©ä½å°æ•¸
}

/**
 * Ad statistics interface
 */
export interface AdStatistics {
  total_views: number;
  total_completions: number;
  completion_rate: number;
  total_quota_earned: number;
  unique_users: number;
}
```

---

### **æ•¸æ“šåº«æŸ¥è©¢æ›´æ–°**

#### **æ›´æ–°ï¼š`src/db/queries/ad_rewards.ts`**

```typescript
/**
 * Increment ad view count (when user clicks watch ad)
 */
export async function incrementAdView(
  db: DatabaseClient,
  telegramId: string
): Promise<void> {
  const today = getTodayDateString();
  
  await db.d1
    .prepare(
      `UPDATE ad_rewards 
       SET ad_views = ad_views + 1,
           updated_at = CURRENT_TIMESTAMP
       WHERE telegram_id = ? AND reward_date = ?`
    )
    .bind(telegramId, today)
    .run();
}

/**
 * Increment ad completion count (when ad finishes successfully)
 */
export async function incrementAdCompletion(
  db: DatabaseClient,
  telegramId: string
): Promise<void> {
  const today = getTodayDateString();
  
  await db.d1
    .prepare(
      `UPDATE ad_rewards 
       SET ad_completions = ad_completions + 1,
           updated_at = CURRENT_TIMESTAMP
       WHERE telegram_id = ? AND reward_date = ?`
    )
    .bind(telegramId, today)
    .run();
}

/**
 * Get today's ad statistics
 */
export async function getTodayAdStatistics(
  db: DatabaseClient
): Promise<AdStatistics> {
  const today = getTodayDateString();
  
  const result = await db.d1
    .prepare(
      `SELECT 
         SUM(ad_views) as total_views,
         SUM(ad_completions) as total_completions,
         SUM(quota_earned) as total_quota_earned,
         COUNT(DISTINCT telegram_id) as unique_users
       FROM ad_rewards
       WHERE reward_date = ?`
    )
    .bind(today)
    .first<{
      total_views: number;
      total_completions: number;
      total_quota_earned: number;
      unique_users: number;
    }>();
  
  const views = result?.total_views || 0;
  const completions = result?.total_completions || 0;
  const completionRate = calculateAdCompletionRate(completions, views);
  
  return {
    total_views: views,
    total_completions: completions,
    completion_rate: completionRate,
    total_quota_earned: result?.total_quota_earned || 0,
    unique_users: result?.unique_users || 0,
  };
}
```

---

### **Handler æ›´æ–°**

#### **æ›´æ–°ï¼š`src/telegram/handlers/ad_reward.ts`**

```typescript
/**
 * Handle watch ad callback
 */
export async function handleWatchAd(
  callbackQuery: CallbackQuery,
  env: Env
): Promise<void> {
  // ... (existing code)

  try {
    // ... (existing checks)

    // âœ¨ NEW: Increment ad view count
    await incrementAdView(db, telegramId);

    // Answer callback first
    await telegram.answerCallbackQuery(callbackQuery.id, 'ğŸ“º æ­£åœ¨åŠ è¼‰å»£å‘Š...');

    // ... (rest of the code)
  } catch (error) {
    // ... (error handling)
  }
}

/**
 * Handle ad completion webhook
 */
export async function handleAdComplete(
  telegramId: string,
  token: string,
  env: Env
): Promise<{ success: boolean; message: string }> {
  const db = createDatabaseClient(env.DB);

  try {
    // ... (existing validation)

    // âœ¨ NEW: Increment ad completion count
    await incrementAdCompletion(db, telegramId);

    // Increment ad reward (quota)
    const updated = await incrementAdReward(db, telegramId);

    // ... (rest of the code)
  } catch (error) {
    // ... (error handling)
  }
}
```

---

### **æ¯æ—¥çµ±è¨ˆå ±è¡¨æ›´æ–°**

#### **æ›´æ–°ï¼š`src/domain/stats.ts`**

```typescript
/**
 * Calculate daily stats including ad statistics
 */
export async function calculateDailyStats(db: DatabaseClient): Promise<DailyStats> {
  const yesterday = getYesterdayDateString();
  
  // ... (existing stats calculations)

  // âœ¨ NEW: Get ad statistics
  const adStats = await getTodayAdStatistics(db);
  
  return {
    // ... (existing fields)
    
    // Ad statistics
    total_ad_views: adStats.total_views,
    total_ad_completions: adStats.total_completions,
    ad_completion_rate: adStats.completion_rate,
    total_ad_quota_earned: adStats.total_quota_earned,
  };
}

/**
 * Format daily stats report with ad statistics
 */
export function formatDailyStatsReport(stats: DailyStats): string {
  return (
    `ğŸ“Š **æ¯æ—¥æ•¸æ“šå ±è¡¨**\n` +
    `ğŸ“… æ—¥æœŸï¼š${stats.stat_date}\n\n` +
    
    `**ç”¨æˆ¶æ•¸æ“š**\n` +
    `â€¢ æ–°å¢ç”¨æˆ¶ï¼š${stats.new_users} äºº\n` +
    `â€¢ æ´»èºç”¨æˆ¶ï¼š${stats.active_users} äºº\n` +
    `â€¢ VIP ç”¨æˆ¶ï¼š${stats.vip_users} äºº\n\n` +
    
    `**æ¼‚æµç“¶æ•¸æ“š**\n` +
    `â€¢ ä¸Ÿå‡ºï¼š${stats.bottles_thrown} å€‹\n` +
    `â€¢ æ’¿èµ·ï¼š${stats.bottles_caught} å€‹\n` +
    `â€¢ å°è©±è¨Šæ¯ï¼š${stats.conversation_messages} å‰‡\n\n` +
    
    `**ğŸ“º å»£å‘Šæ•¸æ“š**\n` +
    `â€¢ è§€çœ‹æ¬¡æ•¸ï¼š${stats.total_ad_views} æ¬¡\n` +
    `â€¢ å®Œæˆæ¬¡æ•¸ï¼š${stats.total_ad_completions} æ¬¡\n` +
    `â€¢ å®Œæˆç‡ï¼š${stats.ad_completion_rate}%\n` +
    `â€¢ ç²å¾—é¡åº¦ï¼š${stats.total_ad_quota_earned} å€‹\n\n` +
    
    `**é‚€è«‹æ•¸æ“š**\n` +
    `â€¢ æ–°å¢é‚€è«‹ï¼š${stats.invites_created} å€‹\n` +
    `â€¢ æ¿€æ´»é‚€è«‹ï¼š${stats.invites_activated} å€‹\n\n` +
    
    `**é¢¨æ§æ•¸æ“š**\n` +
    `â€¢ èˆ‰å ±ï¼š${stats.reports_created} æ¬¡\n` +
    `â€¢ å°ç¦ï¼š${stats.users_banned} äºº`
  );
}
```

---

### **Schema æ›´æ–°**

#### **æ›´æ–°ï¼š`src/db/schema.sql`**

```sql
-- ============================================================================
-- Ad Rewards Table (å»£å‘Šçå‹µ)
-- ============================================================================
CREATE TABLE IF NOT EXISTS ad_rewards (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  telegram_id TEXT NOT NULL,
  reward_date TEXT NOT NULL,  -- YYYY-MM-DD
  ads_watched INTEGER DEFAULT 0,  -- ç•¶å¤©å·²çœ‹å»£å‘Šæ•¸ (0-20)
  quota_earned INTEGER DEFAULT 0,  -- ç•¶å¤©å»£å‘Šç²å¾—çš„é¡åº¦ (0-20)
  ad_views INTEGER DEFAULT 0,  -- å»£å‘Šé–‹å§‹æ’­æ”¾æ¬¡æ•¸
  ad_completions INTEGER DEFAULT 0,  -- å»£å‘Šå®Œæ•´æ’­æ”¾æ¬¡æ•¸
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
  
  UNIQUE(telegram_id, reward_date)
);

CREATE INDEX IF NOT EXISTS idx_ad_rewards_telegram_date 
  ON ad_rewards(telegram_id, reward_date);
CREATE INDEX IF NOT EXISTS idx_ad_rewards_date 
  ON ad_rewards(reward_date);

-- ============================================================================
-- Daily Stats Table (æ¯æ—¥çµ±è¨ˆ)
-- ============================================================================
CREATE TABLE IF NOT EXISTS daily_stats (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  stat_date TEXT NOT NULL UNIQUE,  -- YYYY-MM-DD
  
  -- User stats
  new_users INTEGER DEFAULT 0,
  active_users INTEGER DEFAULT 0,
  vip_users INTEGER DEFAULT 0,
  
  -- Bottle stats
  bottles_thrown INTEGER DEFAULT 0,
  bottles_caught INTEGER DEFAULT 0,
  conversation_messages INTEGER DEFAULT 0,
  
  -- Ad stats
  total_ad_views INTEGER DEFAULT 0,
  total_ad_completions INTEGER DEFAULT 0,
  ad_completion_rate REAL DEFAULT 0.0,
  total_ad_quota_earned INTEGER DEFAULT 0,
  
  -- Invite stats
  invites_created INTEGER DEFAULT 0,
  invites_activated INTEGER DEFAULT 0,
  
  -- Moderation stats
  reports_created INTEGER DEFAULT 0,
  users_banned INTEGER DEFAULT 0,
  
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_daily_stats_date ON daily_stats(stat_date);
```

---

### **ç®¡ç†å“¡å‘½ä»¤**

#### **æ–°å¢å‘½ä»¤ï¼š`/ad_stats`**

**æ–‡ä»¶ï¼š`src/telegram/handlers/admin_stats.ts`**ï¼ˆæ–°å»ºï¼‰

```typescript
/**
 * Admin Stats Handler
 * Show ad statistics to super admin
 */

import type { Env, TelegramMessage } from '~/types';
import { createDatabaseClient } from '~/db/client';
import { createTelegramService } from '~/services/telegram';
import { getTodayAdStatistics } from '~/db/queries/ad_rewards';
import { isSuperAdmin } from './admin_ban';

/**
 * Handle /ad_stats command
 */
export async function handleAdStats(
  message: TelegramMessage,
  env: Env
): Promise<void> {
  const telegram = createTelegramService(env);
  const db = createDatabaseClient(env.DB);
  const chatId = message.chat.id;
  const telegramId = message.from!.id.toString();

  try {
    // Check if super admin
    if (!isSuperAdmin(telegramId, env)) {
      await telegram.sendMessage(chatId, 'âŒ åªæœ‰è¶…ç´šç®¡ç†å“¡å¯ä»¥ä½¿ç”¨æ­¤å‘½ä»¤ã€‚');
      return;
    }

    // Get today's ad statistics
    const stats = await getTodayAdStatistics(db);

    // Format message
    const message =
      `ğŸ“º **ä»Šæ—¥å»£å‘Šçµ±è¨ˆ**\n\n` +
      `**è§€çœ‹æ•¸æ“š**\n` +
      `â€¢ è§€çœ‹æ¬¡æ•¸ï¼š${stats.total_views} æ¬¡\n` +
      `â€¢ å®Œæˆæ¬¡æ•¸ï¼š${stats.total_completions} æ¬¡\n` +
      `â€¢ å®Œæˆç‡ï¼š${stats.completion_rate}%\n\n` +
      `**çå‹µæ•¸æ“š**\n` +
      `â€¢ ç™¼æ”¾é¡åº¦ï¼š${stats.total_quota_earned} å€‹\n` +
      `â€¢ åƒèˆ‡ç”¨æˆ¶ï¼š${stats.unique_users} äºº\n\n` +
      `**å¹³å‡æ•¸æ“š**\n` +
      `â€¢ äººå‡è§€çœ‹ï¼š${stats.unique_users > 0 ? (stats.total_views / stats.unique_users).toFixed(2) : 0} æ¬¡\n` +
      `â€¢ äººå‡å®Œæˆï¼š${stats.unique_users > 0 ? (stats.total_completions / stats.unique_users).toFixed(2) : 0} æ¬¡\n\n` +
      `ğŸ’¡ æŸ¥çœ‹å®Œæ•´å ±è¡¨ï¼š/daily_stats`;

    await telegram.sendMessage(chatId, message);
  } catch (error) {
    console.error('[handleAdStats] Error:', error);
    await telegram.sendMessage(chatId, 'âŒ ç²å–å»£å‘Šçµ±è¨ˆå¤±æ•—');
  }
}
```

---

### **Router é›†æˆ**

#### **æ›´æ–°ï¼š`src/router.ts`**

```typescript
// Ad stats command (Super Admin only)
if (text === '/ad_stats') {
  const adminBanModule = await import('./telegram/handlers/admin_ban');
  if (!adminBanModule.isSuperAdmin(telegramId, env)) {
    await telegram.sendMessage(chatId, 'âŒ åªæœ‰è¶…ç´šç®¡ç†å“¡å¯ä»¥ä½¿ç”¨æ­¤å‘½ä»¤ã€‚');
    return;
  }
  const { handleAdStats } = await import('./telegram/handlers/admin_stats');
  await handleAdStats(message, env);
  return;
}
```

---

### **Help å‘½ä»¤æ›´æ–°**

#### **æ›´æ–°ï¼š`src/telegram/handlers/help.ts`**

```typescript
// Add super admin commands (only for super admin)
if (isUserSuperAdmin) {
  helpMessage += 
    `\n\nğŸ”± **è¶…ç´šç®¡ç†å“¡åŠŸèƒ½**\n` +
    `**ç®¡ç†å“¡ç®¡ç†ï¼š**\n` +
    `/admin_list - æŸ¥çœ‹ç®¡ç†å“¡åˆ—è¡¨\n` +
    `/admin_add <user_id> - æ·»åŠ ç®¡ç†å“¡\n` +
    `/admin_remove <user_id> - ç§»é™¤ç®¡ç†å“¡\n\n` +
    `**å»£æ’­ç³»çµ±ï¼š**\n` +
    `/broadcast <è¨Šæ¯> - ç¾¤ç™¼çµ¦æ‰€æœ‰ç”¨æˆ¶\n` +
    `/broadcast_vip <è¨Šæ¯> - ç¾¤ç™¼çµ¦ VIP ç”¨æˆ¶\n` +
    `/broadcast_non_vip <è¨Šæ¯> - ç¾¤ç™¼çµ¦é VIP ç”¨æˆ¶\n\n` +
    `**çµ±è¨ˆå ±è¡¨ï¼š**\n` +
    `/daily_stats - æŸ¥çœ‹æ¯æ—¥çµ±è¨ˆ\n` +
    `/ad_stats - æŸ¥çœ‹å»£å‘Šçµ±è¨ˆ\n\n` +  // âœ¨ NEW
    `**ç¶­è­·æ¨¡å¼ï¼š**\n` +
    `/maintenance_enable <åˆ†é˜> <è¨Šæ¯> - å•Ÿç”¨ç¶­è­·æ¨¡å¼\n` +
    `/maintenance_disable - é—œé–‰ç¶­è­·æ¨¡å¼\n\n` +
    `**é–‹ç™¼å·¥å…·ï¼š**\n` +
    `/dev_info - ç³»çµ±ä¿¡æ¯\n` +
    `/dev_reset - é‡ç½®å¸³è™Ÿï¼ˆæ¸¬è©¦ç”¨ï¼‰\n` +
    `/dev_restart - å®Œå…¨é‡ç½®å¸³è™Ÿ`;
}
```

---

## âœ… **å»£å‘Šçµ±è¨ˆå¯¦ç¾æª¢æŸ¥æ¸…å–®**

### **Phase 1: æ•¸æ“šåº«**
- [ ] å‰µå»º Migration `0023_add_ad_statistics.sql`
- [ ] åŸ·è¡Œ Migration
- [ ] æ›´æ–° `src/db/schema.sql`

### **Phase 2: Domain & Queries**
- [ ] æ›´æ–° `src/domain/ad_reward.ts` æ·»åŠ çµ±è¨ˆå‡½æ•¸
- [ ] æ›´æ–° `src/db/queries/ad_rewards.ts` æ·»åŠ çµ±è¨ˆæŸ¥è©¢
- [ ] æ›´æ–° `src/domain/stats.ts` é›†æˆå»£å‘Šçµ±è¨ˆ

### **Phase 3: Handler**
- [ ] æ›´æ–° `src/telegram/handlers/ad_reward.ts` è¨˜éŒ„çµ±è¨ˆ
- [ ] å‰µå»º `src/telegram/handlers/admin_stats.ts`
- [ ] æ›´æ–° `src/router.ts` æ·»åŠ  `/ad_stats` è·¯ç”±
- [ ] æ›´æ–° `src/telegram/handlers/help.ts`

### **Phase 4: æ¸¬è©¦**
- [ ] æ¸¬è©¦å»£å‘Šè§€çœ‹çµ±è¨ˆ
- [ ] æ¸¬è©¦å»£å‘Šå®Œæˆçµ±è¨ˆ
- [ ] æ¸¬è©¦æ¯æ—¥å ±è¡¨åŒ…å«å»£å‘Šæ•¸æ“š
- [ ] æ¸¬è©¦ `/ad_stats` å‘½ä»¤

---

## ğŸ“Š **çµ±è¨ˆå ±è¡¨ç¤ºä¾‹**

### **æ¯æ—¥çµ±è¨ˆå ±è¡¨ï¼ˆç™¼é€çµ¦è¶…ç´šç®¡ç†å“¡ï¼‰**
```
ğŸ“Š **æ¯æ—¥æ•¸æ“šå ±è¡¨**
ğŸ“… æ—¥æœŸï¼š2025-01-18

**ç”¨æˆ¶æ•¸æ“š**
â€¢ æ–°å¢ç”¨æˆ¶ï¼š45 äºº
â€¢ æ´»èºç”¨æˆ¶ï¼š328 äºº
â€¢ VIP ç”¨æˆ¶ï¼š23 äºº

**æ¼‚æµç“¶æ•¸æ“š**
â€¢ ä¸Ÿå‡ºï¼š892 å€‹
â€¢ æ’¿èµ·ï¼š856 å€‹
â€¢ å°è©±è¨Šæ¯ï¼š1,234 å‰‡

**ğŸ“º å»£å‘Šæ•¸æ“š**
â€¢ è§€çœ‹æ¬¡æ•¸ï¼š156 æ¬¡
â€¢ å®Œæˆæ¬¡æ•¸ï¼š142 æ¬¡
â€¢ å®Œæˆç‡ï¼š91.03%
â€¢ ç²å¾—é¡åº¦ï¼š142 å€‹

**é‚€è«‹æ•¸æ“š**
â€¢ æ–°å¢é‚€è«‹ï¼š12 å€‹
â€¢ æ¿€æ´»é‚€è«‹ï¼š8 å€‹

**é¢¨æ§æ•¸æ“š**
â€¢ èˆ‰å ±ï¼š3 æ¬¡
â€¢ å°ç¦ï¼š1 äºº
```

### **å¯¦æ™‚å»£å‘Šçµ±è¨ˆï¼ˆ`/ad_stats`ï¼‰**
```
ğŸ“º **ä»Šæ—¥å»£å‘Šçµ±è¨ˆ**

**è§€çœ‹æ•¸æ“š**
â€¢ è§€çœ‹æ¬¡æ•¸ï¼š156 æ¬¡
â€¢ å®Œæˆæ¬¡æ•¸ï¼š142 æ¬¡
â€¢ å®Œæˆç‡ï¼š91.03%

**çå‹µæ•¸æ“š**
â€¢ ç™¼æ”¾é¡åº¦ï¼š142 å€‹
â€¢ åƒèˆ‡ç”¨æˆ¶ï¼š89 äºº

**å¹³å‡æ•¸æ“š**
â€¢ äººå‡è§€çœ‹ï¼š1.75 æ¬¡
â€¢ äººå‡å®Œæˆï¼š1.60 æ¬¡

ğŸ’¡ æŸ¥çœ‹å®Œæ•´å ±è¡¨ï¼š/daily_stats
```

---

**å»£å‘Šçµ±è¨ˆç³»çµ±è¨­è¨ˆå®Œæˆï¼** ğŸ‰

---

## ğŸ”„ **å¤šå»£å‘Šå•†æ”¯æŒè¨­è¨ˆ**

### **éœ€æ±‚**
- æ”¯æŒåˆ‡æ›å¤šå€‹å»£å‘Šå•†ï¼ˆGigaPubã€Google AdSenseã€Unity Ads ç­‰ï¼‰
- å¯é…ç½®å»£å‘Šå•†å„ªå…ˆç´šå’Œæ¬Šé‡
- è‡ªå‹• Fallback æ©Ÿåˆ¶
- çµ±è¨ˆä¸åŒå»£å‘Šå•†çš„è¡¨ç¾

---

### **æ•¸æ“šåº«è¨­è¨ˆ**

#### **æ–°å¢è¡¨ï¼šad_providers**
```sql
-- Migration: 0024_create_ad_providers_table.sql
-- Support multiple ad providers with priority and fallback

CREATE TABLE IF NOT EXISTS ad_providers (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  provider_name TEXT NOT NULL UNIQUE,  -- 'gigapub', 'google_adsense', 'unity_ads', etc.
  provider_display_name TEXT NOT NULL,  -- 'GigaPub', 'Google AdSense', 'Unity Ads'
  is_enabled INTEGER DEFAULT 1,  -- æ˜¯å¦å•Ÿç”¨
  priority INTEGER DEFAULT 0,  -- å„ªå…ˆç´šï¼ˆæ•¸å­—è¶Šå¤§è¶Šå„ªå…ˆï¼‰
  weight INTEGER DEFAULT 100,  -- æ¬Šé‡ï¼ˆç”¨æ–¼è² è¼‰å‡è¡¡ï¼‰
  
  -- Configuration (JSON)
  config TEXT,  -- JSON string: {"project_id": "xxx", "api_key": "xxx", ...}
  
  -- Script URLs
  script_url TEXT,  -- ä¸»è¦è…³æœ¬ URL
  fallback_script_urls TEXT,  -- å‚™ç”¨è…³æœ¬ URLs (JSON array)
  
  -- Statistics
  total_requests INTEGER DEFAULT 0,  -- ç¸½è«‹æ±‚æ¬¡æ•¸
  total_views INTEGER DEFAULT 0,  -- ç¸½è§€çœ‹æ¬¡æ•¸
  total_completions INTEGER DEFAULT 0,  -- ç¸½å®Œæˆæ¬¡æ•¸
  total_errors INTEGER DEFAULT 0,  -- ç¸½éŒ¯èª¤æ¬¡æ•¸
  completion_rate REAL DEFAULT 0.0,  -- å®Œæˆç‡
  
  -- Status
  last_error TEXT,  -- æœ€å¾Œä¸€æ¬¡éŒ¯èª¤
  last_error_at TEXT,  -- æœ€å¾ŒéŒ¯èª¤æ™‚é–“
  last_success_at TEXT,  -- æœ€å¾ŒæˆåŠŸæ™‚é–“
  
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_ad_providers_enabled ON ad_providers(is_enabled);
CREATE INDEX IF NOT EXISTS idx_ad_providers_priority ON ad_providers(priority DESC);
```

#### **æ›´æ–°è¡¨ï¼šad_rewards**
```sql
-- Add provider tracking to ad_rewards
ALTER TABLE ad_rewards ADD COLUMN provider_name TEXT DEFAULT 'gigapub';  -- è¨˜éŒ„ä½¿ç”¨çš„å»£å‘Šå•†
```

#### **æ–°å¢è¡¨ï¼šad_provider_logs**
```sql
-- Detailed logs for each ad request
CREATE TABLE IF NOT EXISTS ad_provider_logs (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  telegram_id TEXT NOT NULL,
  provider_name TEXT NOT NULL,
  request_date TEXT NOT NULL,  -- YYYY-MM-DD HH:MM:SS
  
  -- Request info
  request_type TEXT NOT NULL,  -- 'view' or 'completion'
  
  -- Result
  status TEXT NOT NULL,  -- 'success', 'error', 'timeout'
  error_message TEXT,
  response_time_ms INTEGER,  -- éŸ¿æ‡‰æ™‚é–“ï¼ˆæ¯«ç§’ï¼‰
  
  created_at TEXT DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_ad_provider_logs_telegram ON ad_provider_logs(telegram_id);
CREATE INDEX IF NOT EXISTS idx_ad_provider_logs_provider ON ad_provider_logs(provider_name);
CREATE INDEX IF NOT EXISTS idx_ad_provider_logs_date ON ad_provider_logs(request_date);
```

---

### **Domain é‚è¼¯**

#### **æ–‡ä»¶ï¼š`src/domain/ad_provider.ts`**ï¼ˆæ–°å»ºï¼‰

```typescript
/**
 * Ad Provider Domain Logic
 * Manages multiple ad providers with priority and fallback
 */

export interface AdProvider {
  id: number;
  provider_name: string;
  provider_display_name: string;
  is_enabled: boolean;
  priority: number;
  weight: number;
  config: string;
  script_url: string;
  fallback_script_urls: string;
  total_requests: number;
  total_views: number;
  total_completions: number;
  total_errors: number;
  completion_rate: number;
  last_error?: string;
  last_error_at?: string;
  last_success_at?: string;
  created_at: string;
  updated_at: string;
}

export interface AdProviderConfig {
  project_id?: string;
  api_key?: string;
  app_id?: string;
  placement_id?: string;
  [key: string]: any;
}

export interface AdProviderSelection {
  provider: AdProvider;
  fallback_providers: AdProvider[];
}

/**
 * Provider selection strategy
 */
export type ProviderSelectionStrategy = 'priority' | 'weighted_random' | 'round_robin';

/**
 * Select ad provider based on strategy
 */
export function selectAdProvider(
  providers: AdProvider[],
  strategy: ProviderSelectionStrategy = 'weighted_random'
): AdProviderSelection | null {
  // Filter enabled providers
  const enabled = providers.filter(p => p.is_enabled);
  
  if (enabled.length === 0) {
    return null;
  }
  
  let primary: AdProvider;
  
  switch (strategy) {
    case 'priority':
      primary = selectByPriority(enabled);
      break;
    case 'weighted_random':
      primary = selectByWeightedRandom(enabled);
      break;
    case 'round_robin':
      primary = selectByRoundRobin(enabled);
      break;
    default:
      primary = selectByWeightedRandom(enabled);
  }
  
  // Fallback providers (rest of the list, sorted by priority)
  const fallbacks = enabled
    .filter(p => p.id !== primary.id)
    .sort((a, b) => b.priority - a.priority);
  
  return {
    provider: primary,
    fallback_providers: fallbacks,
  };
}

/**
 * Select provider by priority (highest priority first)
 */
function selectByPriority(providers: AdProvider[]): AdProvider {
  return providers.sort((a, b) => {
    // First by priority
    if (a.priority !== b.priority) {
      return b.priority - a.priority;
    }
    // Then by completion rate
    return b.completion_rate - a.completion_rate;
  })[0];
}

/**
 * Select provider by weighted random (based on weight)
 * 
 * Example:
 * - Provider A: weight 70 â†’ 70% chance
 * - Provider B: weight 20 â†’ 20% chance
 * - Provider C: weight 10 â†’ 10% chance
 */
function selectByWeightedRandom(providers: AdProvider[]): AdProvider {
  // Calculate total weight
  const totalWeight = providers.reduce((sum, p) => sum + p.weight, 0);
  
  if (totalWeight === 0) {
    // If all weights are 0, use priority
    return selectByPriority(providers);
  }
  
  // Generate random number between 0 and totalWeight
  const random = Math.random() * totalWeight;
  
  // Select provider based on weighted random
  let cumulativeWeight = 0;
  for (const provider of providers) {
    cumulativeWeight += provider.weight;
    if (random <= cumulativeWeight) {
      return provider;
    }
  }
  
  // Fallback (should never reach here)
  return providers[0];
}

/**
 * Select provider by round-robin (rotate through providers)
 * 
 * This requires tracking the last used provider index
 * For simplicity, we'll use a hash of current timestamp
 */
function selectByRoundRobin(providers: AdProvider[]): AdProvider {
  // Sort by priority to ensure consistent order
  const sorted = providers.sort((a, b) => b.priority - a.priority);
  
  // Use current second to rotate
  const index = Math.floor(Date.now() / 1000) % sorted.length;
  
  return sorted[index];
}

/**
 * Calculate provider completion rate
 */
export function calculateProviderCompletionRate(
  completions: number,
  views: number
): number {
  if (views === 0) return 0;
  return Math.round((completions / views) * 100 * 100) / 100;
}

/**
 * Parse provider config from JSON string
 */
export function parseProviderConfig(configJson: string): AdProviderConfig {
  try {
    return JSON.parse(configJson);
  } catch {
    return {};
  }
}

/**
 * Parse fallback URLs from JSON string
 */
export function parseFallbackUrls(urlsJson: string): string[] {
  try {
    return JSON.parse(urlsJson);
  } catch {
    return [];
  }
}

/**
 * Check if provider is healthy (low error rate)
 */
export function isProviderHealthy(provider: AdProvider): boolean {
  const totalAttempts = provider.total_views + provider.total_errors;
  if (totalAttempts === 0) return true;
  
  const errorRate = provider.total_errors / totalAttempts;
  
  // Healthy if error rate < 20%
  return errorRate < 0.2;
}
```

---

### **æ•¸æ“šåº«æŸ¥è©¢**

#### **æ–‡ä»¶ï¼š`src/db/queries/ad_providers.ts`**ï¼ˆæ–°å»ºï¼‰

```typescript
/**
 * Ad Providers Database Queries
 */

import type { DatabaseClient } from '../client';
import type { AdProvider } from '~/domain/ad_provider';

/**
 * Get all ad providers
 */
export async function getAllAdProviders(
  db: DatabaseClient
): Promise<AdProvider[]> {
  const result = await db.d1
    .prepare(`SELECT * FROM ad_providers ORDER BY priority DESC, completion_rate DESC`)
    .all<AdProvider>();
  
  return result.results || [];
}

/**
 * Get enabled ad providers
 */
export async function getEnabledAdProviders(
  db: DatabaseClient
): Promise<AdProvider[]> {
  const result = await db.d1
    .prepare(`SELECT * FROM ad_providers WHERE is_enabled = 1 ORDER BY priority DESC`)
    .all<AdProvider>();
  
  return result.results || [];
}

/**
 * Get ad provider by name
 */
export async function getAdProviderByName(
  db: DatabaseClient,
  providerName: string
): Promise<AdProvider | null> {
  const result = await db.d1
    .prepare(`SELECT * FROM ad_providers WHERE provider_name = ?`)
    .bind(providerName)
    .first<AdProvider>();
  
  return result || null;
}

/**
 * Update provider statistics
 */
export async function updateProviderStats(
  db: DatabaseClient,
  providerName: string,
  stats: {
    total_requests?: number;
    total_views?: number;
    total_completions?: number;
    total_errors?: number;
  }
): Promise<void> {
  const updates: string[] = [];
  const bindings: any[] = [];
  
  if (stats.total_requests !== undefined) {
    updates.push('total_requests = total_requests + ?');
    bindings.push(stats.total_requests);
  }
  if (stats.total_views !== undefined) {
    updates.push('total_views = total_views + ?');
    bindings.push(stats.total_views);
  }
  if (stats.total_completions !== undefined) {
    updates.push('total_completions = total_completions + ?');
    bindings.push(stats.total_completions);
  }
  if (stats.total_errors !== undefined) {
    updates.push('total_errors = total_errors + ?');
    bindings.push(stats.total_errors);
  }
  
  if (updates.length === 0) return;
  
  // Calculate new completion rate
  updates.push('completion_rate = ROUND((total_completions * 1.0 / NULLIF(total_views, 0)) * 100, 2)');
  updates.push('updated_at = CURRENT_TIMESTAMP');
  
  bindings.push(providerName);
  
  await db.d1
    .prepare(
      `UPDATE ad_providers 
       SET ${updates.join(', ')}
       WHERE provider_name = ?`
    )
    .bind(...bindings)
    .run();
}

/**
 * Log provider request
 */
export async function logProviderRequest(
  db: DatabaseClient,
  log: {
    telegram_id: string;
    provider_name: string;
    request_type: 'view' | 'completion';
    status: 'success' | 'error' | 'timeout';
    error_message?: string;
    response_time_ms?: number;
  }
): Promise<void> {
  await db.d1
    .prepare(
      `INSERT INTO ad_provider_logs 
       (telegram_id, provider_name, request_date, request_type, status, error_message, response_time_ms)
       VALUES (?, ?, datetime('now'), ?, ?, ?, ?)`
    )
    .bind(
      log.telegram_id,
      log.provider_name,
      log.request_type,
      log.status,
      log.error_message || null,
      log.response_time_ms || null
    )
    .run();
}

/**
 * Update provider error status
 */
export async function updateProviderError(
  db: DatabaseClient,
  providerName: string,
  errorMessage: string
): Promise<void> {
  await db.d1
    .prepare(
      `UPDATE ad_providers 
       SET last_error = ?,
           last_error_at = CURRENT_TIMESTAMP,
           updated_at = CURRENT_TIMESTAMP
       WHERE provider_name = ?`
    )
    .bind(errorMessage, providerName)
    .run();
}

/**
 * Update provider success status
 */
export async function updateProviderSuccess(
  db: DatabaseClient,
  providerName: string
): Promise<void> {
  await db.d1
    .prepare(
      `UPDATE ad_providers 
       SET last_success_at = CURRENT_TIMESTAMP,
           updated_at = CURRENT_TIMESTAMP
       WHERE provider_name = ?`
    )
    .bind(providerName)
    .run();
}
```

---

### **å»£å‘Šé é¢æ›´æ–°**

#### **æ›´æ–°ï¼š`public/ad.html`**

```html
<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>è§€çœ‹å»£å‘Š - XunNi</title>
  
  <!-- Dynamic Ad Provider Script Loading -->
  <script id="ad-loader">
    // Get provider info from URL
    const params = new URLSearchParams(window.location.search);
    const provider = params.get('provider') || 'gigapub';
    const config = params.get('config');
    
    // Load provider script dynamically
    async function loadAdProvider() {
      try {
        // Fetch provider configuration
        const response = await fetch(`/api/ad-provider/${provider}`);
        const providerData = await response.json();
        
        if (!providerData.success) {
          throw new Error(providerData.message || 'Failed to load provider');
        }
        
        // Load primary script
        await loadScript(providerData.script_url, providerData.config);
        
        // Store fallback scripts for later use
        window.adFallbackScripts = providerData.fallback_scripts || [];
        window.currentProviderIndex = 0;
        
      } catch (error) {
        console.error('Failed to load ad provider:', error);
        document.getElementById('status').textContent = 'âŒ å»£å‘Šæœå‹™åŠ è¼‰å¤±æ•—';
        document.getElementById('watchBtn').disabled = true;
      }
    }
    
    // Load script with timeout and fallback
    function loadScript(url, config) {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        
        // Add configuration attributes
        if (config) {
          Object.keys(config).forEach(key => {
            script.setAttribute(`data-${key}`, config[key]);
          });
        }
        
        script.async = true;
        script.src = url;
        
        const timeout = setTimeout(() => {
          script.onload = script.onerror = null;
          reject(new Error('Script load timeout'));
        }, 15000);
        
        script.onload = () => {
          clearTimeout(timeout);
          resolve();
        };
        
        script.onerror = () => {
          clearTimeout(timeout);
          reject(new Error('Script load error'));
        };
        
        document.head.appendChild(script);
      });
    }
    
    // Initialize on page load
    loadAdProvider();
  </script>
  
  <style>
    /* ... (existing styles) ... */
  </style>
</head>
<body>
  <div class="container">
    <div class="icon">ğŸ“º</div>
    <h1>è§€çœ‹å»£å‘Šç²å¾—é¡åº¦</h1>
    <p>è§€çœ‹å®Œæ•´å»£å‘Šå¾Œï¼Œä½ å°‡ç²å¾— +1 æ¼‚æµç“¶é¡åº¦</p>
    <button id="watchBtn" onclick="watchAd()">â–¶ï¸ é–‹å§‹è§€çœ‹</button>
    <div id="status" class="status"></div>
  </div>

  <script>
    // Get URL parameters
    const params = new URLSearchParams(window.location.search);
    const userId = params.get('user');
    const token = params.get('token');
    const provider = params.get('provider') || 'gigapub';

    if (!userId || !token) {
      document.getElementById('status').textContent = 'âŒ ç„¡æ•ˆçš„éˆæ¥';
      document.getElementById('watchBtn').disabled = true;
    }

    // Universal ad watch function with fallback support
    async function watchAd() {
      const btn = document.getElementById('watchBtn');
      const status = document.getElementById('status');
      
      btn.disabled = true;
      status.textContent = 'ğŸ“º æ­£åœ¨åŠ è¼‰å»£å‘Š...';

      try {
        // Try to show ad based on provider
        await showAdByProvider(provider);
        
        // Ad completed successfully
        status.textContent = 'âœ… å»£å‘Šæ’­æ”¾å®Œæˆï¼Œæ­£åœ¨ç™¼æ”¾çå‹µ...';
        
        // Notify backend
        await notifyAdComplete(provider);
        
      } catch (error) {
        console.error('Ad error:', error);
        
        // Try fallback providers
        if (window.adFallbackScripts && window.adFallbackScripts.length > 0) {
          status.textContent = 'â³ å˜—è©¦å‚™ç”¨å»£å‘Šæº...';
          await tryFallbackProviders();
        } else {
          status.textContent = `âŒ ${error.message || 'å»£å‘Šæ’­æ”¾å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦'}`;
          btn.disabled = false;
        }
      }
    }
    
    // Show ad based on provider type
    async function showAdByProvider(providerName) {
      switch (providerName) {
        case 'gigapub':
          if (typeof window.showGiga !== 'function') {
            throw new Error('GigaPub å»£å‘Šæœå‹™æœªå°±ç·’');
          }
          await window.showGiga();
          break;
          
        case 'google_adsense':
          // Google AdSense implementation
          if (typeof window.adsbygoogle === 'undefined') {
            throw new Error('Google AdSense æœªå°±ç·’');
          }
          await showGoogleAd();
          break;
          
        case 'unity_ads':
          // Unity Ads implementation
          if (typeof window.unityShowAd !== 'function') {
            throw new Error('Unity Ads æœªå°±ç·’');
          }
          await window.unityShowAd();
          break;
          
        default:
          throw new Error('ä¸æ”¯æŒçš„å»£å‘Šæä¾›å•†');
      }
    }
    
    // Try fallback providers
    async function tryFallbackProviders() {
      for (let i = 0; i < window.adFallbackScripts.length; i++) {
        try {
          const fallback = window.adFallbackScripts[i];
          await showAdByProvider(fallback.provider_name);
          await notifyAdComplete(fallback.provider_name);
          return; // Success
        } catch (error) {
          console.error(`Fallback ${i + 1} failed:`, error);
        }
      }
      
      // All fallbacks failed
      document.getElementById('status').textContent = 'âŒ æ‰€æœ‰å»£å‘Šæºéƒ½ç„¡æ³•ä½¿ç”¨ï¼Œè«‹ç¨å¾Œå†è©¦';
      document.getElementById('watchBtn').disabled = false;
    }
    
    // Notify backend of ad completion
    async function notifyAdComplete(usedProvider) {
      const response = await fetch('/api/ad-complete', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          user_id: userId,
          token: token,
          provider: usedProvider,
        }),
      });

      const result = await response.json();
      
      if (result.success) {
        document.getElementById('status').textContent = 'ğŸ‰ æ­å–œï¼ä½ ç²å¾—äº† +1 é¡åº¦';
        setTimeout(() => {
          if (window.Telegram && window.Telegram.WebApp) {
            window.Telegram.WebApp.close();
          } else {
            window.close();
          }
        }, 2000);
      } else {
        throw new Error(result.message || 'çå‹µç™¼æ”¾å¤±æ•—');
      }
    }
    
    // Google AdSense specific implementation
    async function showGoogleAd() {
      return new Promise((resolve, reject) => {
        // Implementation depends on Google AdSense setup
        // This is a placeholder
        setTimeout(() => {
          resolve();
        }, 3000);
      });
    }
  </script>
</body>
</html>
```

---

### **API ç«¯é»æ›´æ–°**

#### **æ–°å¢ç«¯é»ï¼š`/api/ad-provider/:provider`**

```typescript
// In src/router.ts

// Get ad provider configuration
if (url.pathname.startsWith('/api/ad-provider/')) {
  const provider = url.pathname.split('/').pop();
  
  try {
    const { getAdProviderByName } = await import('./db/queries/ad_providers');
    const { parseProviderConfig, parseFallbackUrls } = await import('./domain/ad_provider');
    
    const db = createDatabaseClient(env.DB);
    const providerData = await getAdProviderByName(db, provider || '');
    
    if (!providerData || !providerData.is_enabled) {
      return new Response(
        JSON.stringify({ success: false, message: 'Provider not found or disabled' }),
        { status: 404, headers: { 'Content-Type': 'application/json' } }
      );
    }
    
    const config = parseProviderConfig(providerData.config);
    const fallbackUrls = parseFallbackUrls(providerData.fallback_script_urls);
    
    return new Response(
      JSON.stringify({
        success: true,
        provider_name: providerData.provider_name,
        script_url: providerData.script_url,
        config: config,
        fallback_scripts: fallbackUrls,
      }),
      { headers: { 'Content-Type': 'application/json' } }
    );
  } catch (error) {
    return new Response(
      JSON.stringify({ success: false, message: 'Internal server error' }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
}
```

#### **æ›´æ–°ç«¯é»ï¼š`/api/ad-complete`**

```typescript
// Handle ad completion webhook with provider tracking
if (url.pathname === '/api/ad-complete') {
  if (request.method !== 'POST') {
    return new Response('Method not allowed', { status: 405 });
  }

  try {
    const body = await request.json() as { 
      user_id: string; 
      token: string; 
      provider?: string;  // âœ¨ NEW: Track which provider was used
    };
    
    const { handleAdComplete } = await import('./telegram/handlers/ad_reward');
    const result = await handleAdComplete(
      body.user_id, 
      body.token, 
      body.provider || 'gigapub',  // âœ¨ NEW: Pass provider name
      env
    );
    
    return new Response(JSON.stringify(result), {
      headers: { 'Content-Type': 'application/json' },
    });
  } catch (error) {
    return new Response(
      JSON.stringify({ success: false, message: 'Internal server error' }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
}
```

---

### **Handler æ›´æ–°**

#### **æ›´æ–°ï¼š`src/telegram/handlers/ad_reward.ts`**

```typescript
/**
 * Handle watch ad callback with provider selection
 */
export async function handleWatchAd(
  callbackQuery: CallbackQuery,
  env: Env
): Promise<void> {
  const telegram = createTelegramService(env);
  const db = createDatabaseClient(env.DB);
  const chatId = callbackQuery.message!.chat.id;
  const telegramId = callbackQuery.from.id.toString();

  try {
    // ... (existing checks)

    // âœ¨ NEW: Select best ad provider
    const { getEnabledAdProviders } = await import('~/db/queries/ad_providers');
    const { selectAdProvider } = await import('~/domain/ad_provider');
    
    const providers = await getEnabledAdProviders(db);
    const selection = selectAdProvider(providers);
    
    if (!selection) {
      await telegram.answerCallbackQuery(
        callbackQuery.id,
        'âŒ å»£å‘Šæœå‹™æš«æ™‚ä¸å¯ç”¨'
      );
      await telegram.sendMessage(
        chatId,
        'ğŸ“º å»£å‘Šæœå‹™æš«æ™‚ä¸å¯ç”¨\n\n' +
        'è«‹ç¨å¾Œå†è©¦ï¼Œæˆ–è¯ç¹«å®¢æœã€‚'
      );
      return;
    }

    // âœ¨ NEW: Increment ad view count with provider tracking
    await incrementAdView(db, telegramId);
    
    // âœ¨ NEW: Log provider request
    const { logProviderRequest } = await import('~/db/queries/ad_providers');
    await logProviderRequest(db, {
      telegram_id: telegramId,
      provider_name: selection.provider.provider_name,
      request_type: 'view',
      status: 'success',
    });

    // Answer callback first
    await telegram.answerCallbackQuery(callbackQuery.id, 'ğŸ“º æ­£åœ¨åŠ è¼‰å»£å‘Š...');

    // Send ad page URL with provider info
    await telegram.editMessageText(
      chatId,
      loadingMsg.message_id,
      'ğŸ“º **è§€çœ‹å»£å‘Šç²å¾—é¡åº¦**\n\n' +
      `å»£å‘Šæä¾›ï¼š${selection.provider.provider_display_name}\n\n` +
      'é»æ“Šä¸‹æ–¹æŒ‰éˆ•é–‹å§‹è§€çœ‹å»£å‘Šï¼š',
      [
        [
          {
            text: 'â–¶ï¸ é–‹å§‹è§€çœ‹å»£å‘Š',
            url: `https://your-domain.com/ad?user=${telegramId}&token=${generateAdToken(telegramId, env)}&provider=${selection.provider.provider_name}`
          }
        ],
        [
          { text: 'âŒ å–æ¶ˆ', callback_data: 'cancel_ad' }
        ]
      ]
    );

  } catch (error) {
    console.error('[handleWatchAd] Error:', error);
    await telegram.answerCallbackQuery(
      callbackQuery.id,
      'âŒ åŠ è¼‰å»£å‘Šå¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦'
    );
  }
}

/**
 * Handle ad completion webhook with provider tracking
 */
export async function handleAdComplete(
  telegramId: string,
  token: string,
  providerName: string,  // âœ¨ NEW: Track provider
  env: Env
): Promise<{ success: boolean; message: string }> {
  const db = createDatabaseClient(env.DB);

  try {
    // ... (existing validation)

    // âœ¨ NEW: Increment ad completion count
    await incrementAdCompletion(db, telegramId);
    
    // âœ¨ NEW: Update provider statistics
    const { updateProviderStats, updateProviderSuccess, logProviderRequest } = 
      await import('~/db/queries/ad_providers');
    
    await updateProviderStats(db, providerName, {
      total_completions: 1,
    });
    
    await updateProviderSuccess(db, providerName);
    
    await logProviderRequest(db, {
      telegram_id: telegramId,
      provider_name: providerName,
      request_type: 'completion',
      status: 'success',
    });

    // Increment ad reward (quota)
    const updated = await incrementAdReward(db, telegramId);

    // ... (rest of the code)
  } catch (error) {
    // âœ¨ NEW: Log provider error
    const { updateProviderError, logProviderRequest } = 
      await import('~/db/queries/ad_providers');
    
    await updateProviderError(db, providerName, error instanceof Error ? error.message : 'Unknown error');
    
    await logProviderRequest(db, {
      telegram_id: telegramId,
      provider_name: providerName,
      request_type: 'completion',
      status: 'error',
      error_message: error instanceof Error ? error.message : 'Unknown error',
    });
    
    // ... (error handling)
  }
}
```

---

### **ç®¡ç†å“¡å‘½ä»¤**

#### **æ–°å¢å‘½ä»¤ï¼š`/ad_providers`**

```typescript
/**
 * Handle /ad_providers command - List all ad providers
 */
export async function handleAdProviders(
  message: TelegramMessage,
  env: Env
): Promise<void> {
  const telegram = createTelegramService(env);
  const db = createDatabaseClient(env.DB);
  const chatId = message.chat.id;
  const telegramId = message.from!.id.toString();

  try {
    // Check if super admin
    if (!isSuperAdmin(telegramId, env)) {
      await telegram.sendMessage(chatId, 'âŒ åªæœ‰è¶…ç´šç®¡ç†å“¡å¯ä»¥ä½¿ç”¨æ­¤å‘½ä»¤ã€‚');
      return;
    }

    // Get all providers
    const { getAllAdProviders } = await import('~/db/queries/ad_providers');
    const providers = await getAllAdProviders(db);

    if (providers.length === 0) {
      await telegram.sendMessage(chatId, 'ğŸ“º å°šæœªé…ç½®ä»»ä½•å»£å‘Šæä¾›å•†');
      return;
    }

    // Format message
    let message = 'ğŸ“º **å»£å‘Šæä¾›å•†åˆ—è¡¨**\n\n';
    
    providers.forEach((provider, index) => {
      const status = provider.is_enabled ? 'âœ… å•Ÿç”¨' : 'âŒ åœç”¨';
      const health = provider.completion_rate >= 80 ? 'ğŸŸ¢' : provider.completion_rate >= 50 ? 'ğŸŸ¡' : 'ğŸ”´';
      
      message += 
        `**${index + 1}. ${provider.provider_display_name}** ${status}\n` +
        `â€¢ å„ªå…ˆç´šï¼š${provider.priority}\n` +
        `â€¢ å®Œæˆç‡ï¼š${health} ${provider.completion_rate}%\n` +
        `â€¢ ç¸½è«‹æ±‚ï¼š${provider.total_requests} æ¬¡\n` +
        `â€¢ ç¸½å®Œæˆï¼š${provider.total_completions} æ¬¡\n` +
        `â€¢ ç¸½éŒ¯èª¤ï¼š${provider.total_errors} æ¬¡\n`;
      
      if (provider.last_success_at) {
        message += `â€¢ æœ€å¾ŒæˆåŠŸï¼š${provider.last_success_at}\n`;
      }
      
      if (provider.last_error_at) {
        message += `â€¢ æœ€å¾ŒéŒ¯èª¤ï¼š${provider.last_error_at}\n`;
      }
      
      message += '\n';
    });

    await telegram.sendMessage(chatId, message);
  } catch (error) {
    console.error('[handleAdProviders] Error:', error);
    await telegram.sendMessage(chatId, 'âŒ ç²å–å»£å‘Šæä¾›å•†åˆ—è¡¨å¤±æ•—');
  }
}
```

---

### **åˆå§‹åŒ–æ•¸æ“š**

#### **æ–‡ä»¶ï¼š`scripts/init-ad-providers.sql`**

```sql
-- Initialize default ad providers

-- GigaPub (Primary)
INSERT INTO ad_providers (
  provider_name,
  provider_display_name,
  is_enabled,
  priority,
  weight,
  config,
  script_url,
  fallback_script_urls
) VALUES (
  'gigapub',
  'GigaPub',
  1,
  100,
  100,
  '{"project_id": "YOUR_PROJECT_ID"}',
  'https://ad.gigapub.tech/script',
  '["https://ru-ad.gigapub.tech/script"]'
);

-- Google AdSense (Fallback)
INSERT INTO ad_providers (
  provider_name,
  provider_display_name,
  is_enabled,
  0,  -- Disabled by default
  priority,
  80,
  weight,
  '{"client_id": "ca-pub-XXXXXXXXXXXXXXXX"}',
  'https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js',
  '[]'
);

-- Unity Ads (Future)
INSERT INTO ad_providers (
  provider_name,
  provider_display_name,
  is_enabled,
  0,  -- Disabled by default
  priority,
  60,
  weight,
  '{"game_id": "YOUR_GAME_ID", "placement_id": "rewardedVideo"}',
  'https://cdn.unity3d.com/ads/webview/1.0/unity-ads.js',
  '[]'
);
```

---

## âœ… **å¤šå»£å‘Šå•†æ”¯æŒå¯¦ç¾æª¢æŸ¥æ¸…å–®**

### **Phase 1: æ•¸æ“šåº«**
- [ ] å‰µå»º Migration `0024_create_ad_providers_table.sql`
- [ ] å‰µå»º Migration `0025_add_provider_to_ad_rewards.sql`
- [ ] å‰µå»º Migration `0026_create_ad_provider_logs.sql`
- [ ] åŸ·è¡Œ Migrations
- [ ] åˆå§‹åŒ–é»˜èªå»£å‘Šæä¾›å•†æ•¸æ“š

### **Phase 2: Domain & Queries**
- [ ] å‰µå»º `src/domain/ad_provider.ts`
- [ ] å‰µå»º `src/db/queries/ad_providers.ts`

### **Phase 3: Handler & API**
- [ ] æ›´æ–° `src/telegram/handlers/ad_reward.ts` æ”¯æŒå¤šæä¾›å•†
- [ ] æ›´æ–° `src/router.ts` æ·»åŠ  `/api/ad-provider/:provider` ç«¯é»
- [ ] æ›´æ–° `src/router.ts` æ›´æ–° `/api/ad-complete` æ”¯æŒæä¾›å•†è¿½è¹¤

### **Phase 4: å‰ç«¯**
- [ ] æ›´æ–° `public/ad.html` æ”¯æŒå‹•æ…‹åŠ è¼‰æä¾›å•†
- [ ] å¯¦ç¾ Fallback æ©Ÿåˆ¶

### **Phase 5: ç®¡ç†**
- [ ] å‰µå»º `src/telegram/handlers/admin_ad_providers.ts`
- [ ] æ·»åŠ  `/ad_providers` å‘½ä»¤
- [ ] æ›´æ–° `src/telegram/handlers/help.ts`

### **Phase 6: æ¸¬è©¦**
- [ ] æ¸¬è©¦ GigaPub æä¾›å•†
- [ ] æ¸¬è©¦ Fallback æ©Ÿåˆ¶
- [ ] æ¸¬è©¦æä¾›å•†çµ±è¨ˆ
- [ ] æ¸¬è©¦æä¾›å•†åˆ‡æ›

---

## ğŸ“Š **å¤šå»£å‘Šå•†å„ªå‹¢**

### **1. å¯é æ€§**
- âœ… è‡ªå‹• Fallback æ©Ÿåˆ¶
- âœ… å¤šå€‹å‚™ç”¨å»£å‘Šæº
- âœ… é™ä½å–®é»æ•…éšœé¢¨éšª

### **2. æ”¶ç›Šå„ªåŒ–**
- âœ… æ ¹æ“šå®Œæˆç‡é¸æ“‡æœ€ä½³æä¾›å•†
- âœ… æ”¯æŒ A/B æ¸¬è©¦
- âœ… æœ€å¤§åŒ–å»£å‘Šæ”¶å…¥

### **3. éˆæ´»æ€§**
- âœ… è¼•é¬†æ·»åŠ æ–°å»£å‘Šå•†
- âœ… å‹•æ…‹èª¿æ•´å„ªå…ˆç´š
- âœ… å¿«é€Ÿåˆ‡æ›æä¾›å•†

### **4. æ•¸æ“šé©…å‹•**
- âœ… è©³ç´°çš„æä¾›å•†çµ±è¨ˆ
- âœ… æ€§èƒ½å°æ¯”åˆ†æ
- âœ… éŒ¯èª¤è¿½è¹¤

---

**å¤šå»£å‘Šå•†æ”¯æŒè¨­è¨ˆå®Œæˆï¼** ğŸ‰

---

## ğŸ¯ **è¼ªæ’­å’Œæ¬Šé‡åˆ†é…è©³è§£**

### **ä¸‰ç¨®é¸æ“‡ç­–ç•¥**

#### **1. Priorityï¼ˆå„ªå…ˆç´šï¼‰**
- **é‚è¼¯**ï¼šå§‹çµ‚é¸æ“‡å„ªå…ˆç´šæœ€é«˜çš„æä¾›å•†
- **é©ç”¨å ´æ™¯**ï¼šæƒ³è¦å›ºå®šä½¿ç”¨æŸå€‹å»£å‘Šå•†
- **ç¤ºä¾‹**ï¼š
  ```
  Provider A: priority 100 â†’ å§‹çµ‚é¸æ“‡
  Provider B: priority 80  â†’ åƒ…ä½œç‚º Fallback
  Provider C: priority 60  â†’ åƒ…ä½œç‚º Fallback
  ```

#### **2. Weighted Randomï¼ˆæ¬Šé‡éš¨æ©Ÿï¼‰** â­ **æ¨è–¦**
- **é‚è¼¯**ï¼šæ ¹æ“šæ¬Šé‡éš¨æ©Ÿé¸æ“‡ï¼Œæ¬Šé‡è¶Šé«˜è¢«é¸ä¸­æ©Ÿç‡è¶Šå¤§
- **é©ç”¨å ´æ™¯**ï¼šå¤šå€‹å»£å‘Šå•†æŒ‰æ¯”ä¾‹è¼ªæ’­
- **ç¤ºä¾‹**ï¼š
  ```
  Provider A: weight 70 â†’ 70% æ©Ÿç‡
  Provider B: weight 20 â†’ 20% æ©Ÿç‡
  Provider C: weight 10 â†’ 10% æ©Ÿç‡
  
  ç¸½æ¬Šé‡ = 100
  æ¯æ¬¡éš¨æ©Ÿé¸æ“‡ï¼Œç¬¦åˆè¨­å®šçš„æ¯”ä¾‹
  ```

#### **3. Round Robinï¼ˆè¼ªè©¢ï¼‰**
- **é‚è¼¯**ï¼šæŒ‰é †åºè¼ªæµé¸æ“‡æä¾›å•†
- **é©ç”¨å ´æ™¯**ï¼šå¹³å‡åˆ†é…æµé‡
- **ç¤ºä¾‹**ï¼š
  ```
  ç¬¬ 1 æ¬¡è«‹æ±‚ â†’ Provider A
  ç¬¬ 2 æ¬¡è«‹æ±‚ â†’ Provider B
  ç¬¬ 3 æ¬¡è«‹æ±‚ â†’ Provider C
  ç¬¬ 4 æ¬¡è«‹æ±‚ â†’ Provider A
  ...å¾ªç’°
  ```

---

### **é…ç½®ç¤ºä¾‹**

#### **å ´æ™¯ 1ï¼šä¸»åŠ› GigaPubï¼Œå‚™ç”¨ Google**
```sql
-- GigaPub (ä¸»åŠ› 80%)
UPDATE ad_providers 
SET weight = 80, priority = 100, is_enabled = 1
WHERE provider_name = 'gigapub';

-- Google AdSense (å‚™ç”¨ 20%)
UPDATE ad_providers 
SET weight = 20, priority = 90, is_enabled = 1
WHERE provider_name = 'google_adsense';

-- é¸æ“‡ç­–ç•¥ï¼šweighted_random
```

**æ•ˆæœ**ï¼š
- 80% çš„ç”¨æˆ¶çœ‹åˆ° GigaPub å»£å‘Š
- 20% çš„ç”¨æˆ¶çœ‹åˆ° Google AdSense å»£å‘Š
- å¦‚æœ GigaPub å¤±æ•—ï¼Œè‡ªå‹• Fallback åˆ° Google

---

#### **å ´æ™¯ 2ï¼šä¸‰å€‹å»£å‘Šå•†å¹³å‡è¼ªæ’­**
```sql
-- GigaPub
UPDATE ad_providers 
SET weight = 33, priority = 100, is_enabled = 1
WHERE provider_name = 'gigapub';

-- Google AdSense
UPDATE ad_providers 
SET weight = 33, priority = 100, is_enabled = 1
WHERE provider_name = 'google_adsense';

-- Unity Ads
UPDATE ad_providers 
SET weight = 34, priority = 100, is_enabled = 1
WHERE provider_name = 'unity_ads';

-- é¸æ“‡ç­–ç•¥ï¼šweighted_random æˆ– round_robin
```

**æ•ˆæœ**ï¼š
- æ¯å€‹å»£å‘Šå•†ç´„ 33% æµé‡
- å¹³å‡åˆ†é…ï¼Œæ¸¬è©¦ä¸åŒå»£å‘Šå•†æ•ˆæœ

---

#### **å ´æ™¯ 3ï¼šåªç”¨ä¸€å€‹å»£å‘Šå•†**
```sql
-- GigaPub (å”¯ä¸€å•Ÿç”¨)
UPDATE ad_providers 
SET weight = 100, priority = 100, is_enabled = 1
WHERE provider_name = 'gigapub';

-- å…¶ä»–å…¨éƒ¨åœç”¨
UPDATE ad_providers 
SET is_enabled = 0
WHERE provider_name != 'gigapub';

-- é¸æ“‡ç­–ç•¥ï¼šä»»æ„
```

**æ•ˆæœ**ï¼š
- 100% ä½¿ç”¨ GigaPub
- å…¶ä»–å»£å‘Šå•†ä½œç‚ºç·Šæ€¥å‚™ç”¨

---

### **ç’°å¢ƒè®Šæ•¸é…ç½®**

#### **æ·»åŠ åˆ° `wrangler.toml`**
```toml
[env.staging.vars]
# ... existing vars ...
AD_PROVIDER_STRATEGY = "weighted_random"  # 'priority' | 'weighted_random' | 'round_robin'

[env.production.vars]
# ... existing vars ...
AD_PROVIDER_STRATEGY = "weighted_random"
```

---

### **Handler æ›´æ–°**

#### **æ›´æ–°ï¼š`src/telegram/handlers/ad_reward.ts`**

```typescript
/**
 * Handle watch ad callback with configurable strategy
 */
export async function handleWatchAd(
  callbackQuery: CallbackQuery,
  env: Env
): Promise<void> {
  // ... (existing code)

  try {
    // ... (existing checks)

    // âœ¨ NEW: Get selection strategy from env
    const strategy = (env.AD_PROVIDER_STRATEGY || 'weighted_random') as ProviderSelectionStrategy;

    // âœ¨ NEW: Select best ad provider with strategy
    const { getEnabledAdProviders } = await import('~/db/queries/ad_providers');
    const { selectAdProvider } = await import('~/domain/ad_provider');
    
    const providers = await getEnabledAdProviders(db);
    const selection = selectAdProvider(providers, strategy);  // âœ¨ Pass strategy
    
    if (!selection) {
      await telegram.answerCallbackQuery(
        callbackQuery.id,
        'âŒ å»£å‘Šæœå‹™æš«æ™‚ä¸å¯ç”¨'
      );
      return;
    }

    // Log selected provider and strategy
    console.log(`[handleWatchAd] Selected provider: ${selection.provider.provider_name} using strategy: ${strategy}`);

    // ... (rest of the code)
  } catch (error) {
    // ... (error handling)
  }
}
```

---

### **ç®¡ç†å“¡å‘½ä»¤æ›´æ–°**

#### **æ–°å¢å‘½ä»¤ï¼š`/ad_strategy <strategy>`**

```typescript
/**
 * Handle /ad_strategy command - Change provider selection strategy
 */
export async function handleAdStrategy(
  message: TelegramMessage,
  env: Env
): Promise<void> {
  const telegram = createTelegramService(env);
  const chatId = message.chat.id;
  const telegramId = message.from!.id.toString();
  const text = message.text || '';

  try {
    // Check if super admin
    if (!isSuperAdmin(telegramId, env)) {
      await telegram.sendMessage(chatId, 'âŒ åªæœ‰è¶…ç´šç®¡ç†å“¡å¯ä»¥ä½¿ç”¨æ­¤å‘½ä»¤ã€‚');
      return;
    }

    const parts = text.split(' ');
    
    // Show current strategy
    if (parts.length === 1) {
      const currentStrategy = env.AD_PROVIDER_STRATEGY || 'weighted_random';
      await telegram.sendMessage(
        chatId,
        `ğŸ“º **ç•¶å‰å»£å‘Šé¸æ“‡ç­–ç•¥**\n\n` +
        `ç­–ç•¥ï¼š${currentStrategy}\n\n` +
        `**å¯ç”¨ç­–ç•¥ï¼š**\n` +
        `â€¢ \`priority\` - å„ªå…ˆç´šï¼ˆå›ºå®šé¸æ“‡ï¼‰\n` +
        `â€¢ \`weighted_random\` - æ¬Šé‡éš¨æ©Ÿï¼ˆæŒ‰æ¯”ä¾‹ï¼‰â­\n` +
        `â€¢ \`round_robin\` - è¼ªè©¢ï¼ˆå¹³å‡åˆ†é…ï¼‰\n\n` +
        `**ä¿®æ”¹ç­–ç•¥ï¼š**\n` +
        `/ad_strategy <ç­–ç•¥åç¨±>\n\n` +
        `**ç¤ºä¾‹ï¼š**\n` +
        `/ad_strategy weighted_random`
      );
      return;
    }

    // Change strategy
    const newStrategy = parts[1];
    const validStrategies = ['priority', 'weighted_random', 'round_robin'];
    
    if (!validStrategies.includes(newStrategy)) {
      await telegram.sendMessage(
        chatId,
        `âŒ ç„¡æ•ˆçš„ç­–ç•¥ï¼š${newStrategy}\n\n` +
        `æœ‰æ•ˆç­–ç•¥ï¼špriority, weighted_random, round_robin`
      );
      return;
    }

    // Note: Changing env vars at runtime is not directly supported
    // This would require updating wrangler.toml and redeploying
    await telegram.sendMessage(
      chatId,
      `âš ï¸ **ç­–ç•¥ä¿®æ”¹èªªæ˜**\n\n` +
      `è¦ä¿®æ”¹å»£å‘Šé¸æ“‡ç­–ç•¥ï¼Œè«‹ï¼š\n\n` +
      `1. æ›´æ–° \`wrangler.toml\`ï¼š\n` +
      `\`\`\`\n` +
      `AD_PROVIDER_STRATEGY = "${newStrategy}"\n` +
      `\`\`\`\n\n` +
      `2. é‡æ–°éƒ¨ç½²ï¼š\n` +
      `\`\`\`\n` +
      `pnpm deploy:staging\n` +
      `\`\`\`\n\n` +
      `ğŸ’¡ æœªä¾†å¯ä»¥è€ƒæ…®å°‡ç­–ç•¥å­˜å„²åœ¨æ•¸æ“šåº«ä¸­ï¼Œå¯¦ç¾å‹•æ…‹åˆ‡æ›ã€‚`
    );

  } catch (error) {
    console.error('[handleAdStrategy] Error:', error);
    await telegram.sendMessage(chatId, 'âŒ è™•ç†å‘½ä»¤å¤±æ•—');
  }
}
```

---

### **æ¬Šé‡èª¿æ•´å‘½ä»¤**

#### **æ–°å¢å‘½ä»¤ï¼š`/ad_weight <provider> <weight>`**

```typescript
/**
 * Handle /ad_weight command - Adjust provider weight
 */
export async function handleAdWeight(
  message: TelegramMessage,
  env: Env
): Promise<void> {
  const telegram = createTelegramService(env);
  const db = createDatabaseClient(env.DB);
  const chatId = message.chat.id;
  const telegramId = message.from!.id.toString();
  const text = message.text || '';

  try {
    // Check if super admin
    if (!isSuperAdmin(telegramId, env)) {
      await telegram.sendMessage(chatId, 'âŒ åªæœ‰è¶…ç´šç®¡ç†å“¡å¯ä»¥ä½¿ç”¨æ­¤å‘½ä»¤ã€‚');
      return;
    }

    const parts = text.split(' ');
    
    // Show usage
    if (parts.length < 3) {
      await telegram.sendMessage(
        chatId,
        `ğŸ“º **èª¿æ•´å»£å‘Šå•†æ¬Šé‡**\n\n` +
        `**ä½¿ç”¨æ–¹æ³•ï¼š**\n` +
        `/ad_weight <æä¾›å•†> <æ¬Šé‡>\n\n` +
        `**ç¤ºä¾‹ï¼š**\n` +
        `/ad_weight gigapub 70\n` +
        `/ad_weight google_adsense 30\n\n` +
        `ğŸ’¡ æ¬Šé‡ç¸½å’Œä¸éœ€è¦ç­‰æ–¼ 100ï¼Œç³»çµ±æœƒè‡ªå‹•è¨ˆç®—æ¯”ä¾‹ã€‚\n\n` +
        `**æŸ¥çœ‹ç•¶å‰é…ç½®ï¼š**\n` +
        `/ad_providers`
      );
      return;
    }

    const providerName = parts[1];
    const weight = parseInt(parts[2]);

    if (isNaN(weight) || weight < 0 || weight > 1000) {
      await telegram.sendMessage(chatId, 'âŒ æ¬Šé‡å¿…é ˆæ˜¯ 0-1000 ä¹‹é–“çš„æ•¸å­—');
      return;
    }

    // Update weight
    const result = await db.d1
      .prepare(
        `UPDATE ad_providers 
         SET weight = ?, updated_at = CURRENT_TIMESTAMP
         WHERE provider_name = ?`
      )
      .bind(weight, providerName)
      .run();

    if (result.meta.changes === 0) {
      await telegram.sendMessage(chatId, `âŒ æ‰¾ä¸åˆ°æä¾›å•†ï¼š${providerName}`);
      return;
    }

    // Get updated provider info
    const { getAdProviderByName } = await import('~/db/queries/ad_providers');
    const provider = await getAdProviderByName(db, providerName);

    if (!provider) {
      await telegram.sendMessage(chatId, 'âŒ æ›´æ–°å¤±æ•—');
      return;
    }

    await telegram.sendMessage(
      chatId,
      `âœ… **æ¬Šé‡å·²æ›´æ–°**\n\n` +
      `æä¾›å•†ï¼š${provider.provider_display_name}\n` +
      `æ–°æ¬Šé‡ï¼š${weight}\n\n` +
      `ğŸ’¡ æ–°æ¬Šé‡å°‡åœ¨ä¸‹æ¬¡å»£å‘Šè«‹æ±‚æ™‚ç”Ÿæ•ˆã€‚\n\n` +
      `æŸ¥çœ‹æ‰€æœ‰æä¾›å•†ï¼š/ad_providers`
    );

  } catch (error) {
    console.error('[handleAdWeight] Error:', error);
    await telegram.sendMessage(chatId, 'âŒ æ›´æ–°æ¬Šé‡å¤±æ•—');
  }
}
```

---

### **Router é›†æˆ**

```typescript
// In src/router.ts

// Ad strategy command (Super Admin only)
if (text === '/ad_strategy' || text.startsWith('/ad_strategy ')) {
  const adminBanModule = await import('./telegram/handlers/admin_ban');
  if (!adminBanModule.isSuperAdmin(telegramId, env)) {
    await telegram.sendMessage(chatId, 'âŒ åªæœ‰è¶…ç´šç®¡ç†å“¡å¯ä»¥ä½¿ç”¨æ­¤å‘½ä»¤ã€‚');
    return;
  }
  const { handleAdStrategy } = await import('./telegram/handlers/admin_ad_providers');
  await handleAdStrategy(message, env);
  return;
}

// Ad weight command (Super Admin only)
if (text.startsWith('/ad_weight ')) {
  const adminBanModule = await import('./telegram/handlers/admin_ban');
  if (!adminBanModule.isSuperAdmin(telegramId, env)) {
    await telegram.sendMessage(chatId, 'âŒ åªæœ‰è¶…ç´šç®¡ç†å“¡å¯ä»¥ä½¿ç”¨æ­¤å‘½ä»¤ã€‚');
    return;
  }
  const { handleAdWeight } = await import('./telegram/handlers/admin_ad_providers');
  await handleAdWeight(message, env);
  return;
}
```

---

### **Help å‘½ä»¤æ›´æ–°**

```typescript
// Add super admin commands
if (isUserSuperAdmin) {
  helpMessage += 
    `\n\nğŸ”± **è¶…ç´šç®¡ç†å“¡åŠŸèƒ½**\n` +
    // ... existing commands ...
    `**å»£å‘Šç®¡ç†ï¼š**\n` +
    `/ad_providers - æŸ¥çœ‹å»£å‘Šå•†åˆ—è¡¨\n` +
    `/ad_stats - æŸ¥çœ‹å»£å‘Šçµ±è¨ˆ\n` +
    `/ad_strategy [ç­–ç•¥] - æŸ¥çœ‹/ä¿®æ”¹é¸æ“‡ç­–ç•¥\n` +
    `/ad_weight <æä¾›å•†> <æ¬Šé‡> - èª¿æ•´æ¬Šé‡\n\n` +
    // ... other commands ...
}
```

---

## ğŸ“Š **å¯¦éš›æ•ˆæœæ¼”ç¤º**

### **æ¸¬è©¦ 1ï¼šæ¬Šé‡éš¨æ©Ÿï¼ˆ70:20:10ï¼‰**

```sql
-- é…ç½®
UPDATE ad_providers SET weight = 70 WHERE provider_name = 'gigapub';
UPDATE ad_providers SET weight = 20 WHERE provider_name = 'google_adsense';
UPDATE ad_providers SET weight = 10 WHERE provider_name = 'unity_ads';
```

**100 æ¬¡è«‹æ±‚çµæœï¼ˆé æœŸï¼‰ï¼š**
```
GigaPub:        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 70 æ¬¡
Google AdSense: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 20 æ¬¡
Unity Ads:      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 10 æ¬¡
```

---

### **æ¸¬è©¦ 2ï¼šè¼ªè©¢ï¼ˆå¹³å‡åˆ†é…ï¼‰**

```sql
-- é…ç½®ï¼ˆæ¬Šé‡ä¸é‡è¦ï¼Œå› ç‚ºä½¿ç”¨ round_robinï¼‰
UPDATE ad_providers SET priority = 100 WHERE provider_name = 'gigapub';
UPDATE ad_providers SET priority = 100 WHERE provider_name = 'google_adsense';
UPDATE ad_providers SET priority = 100 WHERE provider_name = 'unity_ads';
```

**12 æ¬¡è«‹æ±‚çµæœï¼š**
```
è«‹æ±‚ 1: GigaPub
è«‹æ±‚ 2: Google AdSense
è«‹æ±‚ 3: Unity Ads
è«‹æ±‚ 4: GigaPub
è«‹æ±‚ 5: Google AdSense
è«‹æ±‚ 6: Unity Ads
è«‹æ±‚ 7: GigaPub
è«‹æ±‚ 8: Google AdSense
è«‹æ±‚ 9: Unity Ads
è«‹æ±‚ 10: GigaPub
è«‹æ±‚ 11: Google AdSense
è«‹æ±‚ 12: Unity Ads
```

---

### **æ¸¬è©¦ 3ï¼šå„ªå…ˆç´šï¼ˆå›ºå®šé¸æ“‡ï¼‰**

```sql
-- é…ç½®
UPDATE ad_providers SET priority = 100 WHERE provider_name = 'gigapub';
UPDATE ad_providers SET priority = 80 WHERE provider_name = 'google_adsense';
UPDATE ad_providers SET priority = 60 WHERE provider_name = 'unity_ads';
```

**100 æ¬¡è«‹æ±‚çµæœï¼š**
```
GigaPub: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 100 æ¬¡
Google AdSense: 0 æ¬¡ï¼ˆåƒ…ä½œç‚º Fallbackï¼‰
Unity Ads: 0 æ¬¡ï¼ˆåƒ…ä½œç‚º Fallbackï¼‰
```

---

## ğŸ¯ **æœ€ä½³å¯¦è¸å»ºè­°**

### **1. åˆæœŸæ¸¬è©¦éšæ®µ**
```
ç­–ç•¥ï¼šweighted_random
GigaPub: 50%
Google AdSense: 30%
Unity Ads: 20%

ç›®çš„ï¼šæ¸¬è©¦ä¸åŒå»£å‘Šå•†çš„è¡¨ç¾
```

### **2. ç©©å®šé‹ç‡Ÿéšæ®µ**
```
ç­–ç•¥ï¼šweighted_random
æœ€ä½³å»£å‘Šå•†: 70%
æ¬¡ä½³å»£å‘Šå•†: 20%
å‚™ç”¨å»£å‘Šå•†: 10%

ç›®çš„ï¼šæœ€å¤§åŒ–æ”¶ç›Šï¼Œä¿ç•™å‚™ç”¨
```

### **3. å–®ä¸€å»£å‘Šå•†éšæ®µ**
```
ç­–ç•¥ï¼špriority
ä¸»åŠ›å»£å‘Šå•†: priority 100
å…¶ä»–å…¨éƒ¨åœç”¨

ç›®çš„ï¼šå°ˆæ³¨å–®ä¸€å»£å‘Šå•†ï¼Œç°¡åŒ–ç®¡ç†
```

---

## âœ… **æ›´æ–°çš„å¯¦ç¾æª¢æŸ¥æ¸…å–®**

### **Phase 1: Domain é‚è¼¯**
- [ ] æ›´æ–° `src/domain/ad_provider.ts` æ·»åŠ ä¸‰ç¨®é¸æ“‡ç­–ç•¥
- [ ] å¯¦ç¾ `selectByPriority()`
- [ ] å¯¦ç¾ `selectByWeightedRandom()`
- [ ] å¯¦ç¾ `selectByRoundRobin()`

### **Phase 2: Handler**
- [ ] æ›´æ–° `src/telegram/handlers/ad_reward.ts` æ”¯æŒç­–ç•¥åƒæ•¸
- [ ] å‰µå»º `src/telegram/handlers/admin_ad_providers.ts`
- [ ] å¯¦ç¾ `/ad_strategy` å‘½ä»¤
- [ ] å¯¦ç¾ `/ad_weight` å‘½ä»¤

### **Phase 3: é…ç½®**
- [ ] æ·»åŠ  `AD_PROVIDER_STRATEGY` åˆ° `wrangler.toml`
- [ ] æ›´æ–° `src/router.ts` æ·»åŠ æ–°å‘½ä»¤è·¯ç”±
- [ ] æ›´æ–° `src/telegram/handlers/help.ts`

### **Phase 4: æ¸¬è©¦**
- [ ] æ¸¬è©¦ Priority ç­–ç•¥
- [ ] æ¸¬è©¦ Weighted Random ç­–ç•¥
- [ ] æ¸¬è©¦ Round Robin ç­–ç•¥
- [ ] æ¸¬è©¦æ¬Šé‡èª¿æ•´å‘½ä»¤
- [ ] é©—è­‰çµ±è¨ˆæ•¸æ“šæº–ç¢ºæ€§

---

**è¼ªæ’­å’Œæ¬Šé‡åˆ†é…åŠŸèƒ½è¨­è¨ˆå®Œæˆï¼** ğŸ‰

---

## ğŸ¯ **å®˜æ–¹æ–‡å­—å»£å‘Šç³»çµ±** â­ **æ–°å¢åŠŸèƒ½**

### **æ ¸å¿ƒç‰¹é»**

1. **é»æ“Šå³çå‹µ**ï¼šç„¡éœ€ç­‰å¾…è¦–é »æ’­æ”¾ï¼Œé»æ“Šå¾Œç«‹å³ +1 é¡åº¦
2. **ä¸€æ¬¡æ€§æ¨é€**ï¼šæ¯å€‹å»£å‘Šåªæ¨é€ä¸€æ¬¡çµ¦æ¯å€‹ç”¨æˆ¶
3. **ä¸è¨ˆå…¥é™åˆ¶**ï¼šä¸è¨ˆå…¥æ¯æ—¥ 20 æ¬¡ç¬¬ä¸‰æ–¹å»£å‘Šé™åˆ¶
4. **æ”¯æŒèªè­‰**ï¼šç¾¤çµ„/é »é“é¡å‹å¯è¦æ±‚åŠ å…¥å¾Œèªè­‰æ‰ç™¼æ”¾çå‹µ
5. **éˆæ´»é…ç½®**ï¼šæ”¯æŒå¤šç¨®å»£å‘Šé¡å‹å’Œè‡ªå®šç¾©çå‹µé¡åº¦
6. **æ°¸ä¹…é¡åº¦**ï¼šå®˜æ–¹å»£å‘Šçå‹µæ˜¯æ°¸ä¹…é¡åº¦ï¼ˆåŠ åˆ° invite_bonusï¼‰ï¼Œä¸æ˜¯è‡¨æ™‚çš„

---

### **å»£å‘Šé¡å‹**

#### **1. Textï¼ˆç´”æ–‡å­—å…¬å‘Šï¼‰**
```typescript
{
  ad_type: 'text',
  title: 'ğŸ‰ XunNi æ–°åŠŸèƒ½ä¸Šç·š',
  content: 'æˆ‘å€‘æ¨å‡ºäº†å…¨æ–°çš„ VIP åŠŸèƒ½ï¼Œå¿«ä¾†é«”é©—å§ï¼\n\né»æ“Šæ­¤è¨Šæ¯å³å¯ç²å¾— +1 é¡åº¦çå‹µï¼',
  reward_quota: 1
}
```

**ç‰¹é»**ï¼š
- âœ… ç´”æ–‡å­—å…§å®¹
- âœ… é»æ“Šå³çå‹µ
- âœ… é©åˆå…¬å‘Šã€æ´»å‹•é€šçŸ¥

#### **2. Linkï¼ˆéˆæ¥æ¨å»£ï¼‰**
```typescript
{
  ad_type: 'link',
  title: 'ğŸ“± ä¸‹è¼‰ XunNi Mini App',
  content: 'é»æ“Šä¸‹æ–¹æŒ‰éˆ•ä¸‹è¼‰æˆ‘å€‘çš„ Mini Appï¼Œé«”é©—æ›´å¤šåŠŸèƒ½ï¼',
  url: 'https://t.me/xunni_bot/app',
  reward_quota: 1
}
```

**ç‰¹é»**ï¼š
- âœ… å¸¶éˆæ¥æŒ‰éˆ•
- âœ… é»æ“Šéˆæ¥å¾Œçå‹µ
- âœ… é©åˆæ¨å»£ç¶²ç«™ã€Mini App

#### **3. Groupï¼ˆç¾¤çµ„é‚€è«‹ï¼‰**
```typescript
{
  ad_type: 'group',
  title: 'ğŸ‘¥ åŠ å…¥ XunNi å®˜æ–¹ç¾¤çµ„',
  content: 'åŠ å…¥æˆ‘å€‘çš„å®˜æ–¹ç¾¤çµ„ï¼Œèˆ‡æ›´å¤šç”¨æˆ¶äº¤æµï¼',
  url: 'https://t.me/xunni_group',
  target_entity_id: '-1001234567890',  // ç¾¤çµ„ ID
  requires_verification: 1,  // éœ€è¦èªè­‰
  reward_quota: 2  // åŠ å…¥ç¾¤çµ„çå‹µ 2 é¡åº¦
}
```

**ç‰¹é»**ï¼š
- âœ… é‚€è«‹åŠ å…¥ç¾¤çµ„
- âœ… å¯é¸èªè­‰ï¼ˆæ©Ÿå™¨äººæª¢æŸ¥ç”¨æˆ¶æ˜¯å¦åœ¨ç¾¤çµ„ä¸­ï¼‰
- âœ… çå‹µæ›´é«˜ï¼ˆ2 é¡åº¦ï¼‰

#### **4. Channelï¼ˆé »é“è¨‚é–±ï¼‰**
```typescript
{
  ad_type: 'channel',
  title: 'ğŸ“¢ è¨‚é–± XunNi å®˜æ–¹é »é“',
  content: 'è¨‚é–±æˆ‘å€‘çš„å®˜æ–¹é »é“ï¼Œç¬¬ä¸€æ™‚é–“ç²å–æœ€æ–°æ¶ˆæ¯ï¼',
  url: 'https://t.me/xunni_channel',
  target_entity_id: '@xunni_channel',  // é »é“ username
  requires_verification: 1,
  reward_quota: 2
}
```

**ç‰¹é»**ï¼š
- âœ… é‚€è«‹è¨‚é–±é »é“
- âœ… å¯é¸èªè­‰ï¼ˆæ©Ÿå™¨äººæª¢æŸ¥ç”¨æˆ¶æ˜¯å¦è¨‚é–±ï¼‰
- âœ… çå‹µæ›´é«˜ï¼ˆ2 é¡åº¦ï¼‰

---

### **æ•¸æ“šåº« Migration**

#### **æ–‡ä»¶ï¼š`src/db/migrations/0027_create_official_ads.sql`**

```sql
-- Official Ads System
-- Allows XunNi to create text/link ads with instant rewards

-- Official ads table
CREATE TABLE IF NOT EXISTS official_ads (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  ad_type TEXT NOT NULL CHECK(ad_type IN ('text', 'link', 'group', 'channel')),
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  url TEXT,
  target_entity_id TEXT,
  reward_quota INTEGER DEFAULT 1 CHECK(reward_quota >= 1 AND reward_quota <= 10),
  is_enabled INTEGER DEFAULT 1,
  start_date TEXT,
  end_date TEXT,
  max_views INTEGER,
  current_views INTEGER DEFAULT 0,
  requires_verification INTEGER DEFAULT 0,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_official_ads_enabled ON official_ads(is_enabled, start_date, end_date);
CREATE INDEX idx_official_ads_type ON official_ads(ad_type);

-- Official ad views table
CREATE TABLE IF NOT EXISTS official_ad_views (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  telegram_id TEXT NOT NULL,
  ad_id INTEGER NOT NULL,
  viewed_at TEXT DEFAULT CURRENT_TIMESTAMP,
  clicked INTEGER DEFAULT 0,
  clicked_at TEXT,
  verified INTEGER DEFAULT 0,
  verified_at TEXT,
  reward_granted INTEGER DEFAULT 0,
  reward_granted_at TEXT,
  
  UNIQUE(telegram_id, ad_id),
  FOREIGN KEY (ad_id) REFERENCES official_ads(id) ON DELETE CASCADE
);

CREATE INDEX idx_official_ad_views_telegram ON official_ad_views(telegram_id);
CREATE INDEX idx_official_ad_views_ad ON official_ad_views(ad_id);
CREATE INDEX idx_official_ad_views_reward ON official_ad_views(reward_granted);
```

---

### **Domain é‚è¼¯**

#### **æ–‡ä»¶ï¼š`src/domain/official_ad.ts`**ï¼ˆæ–°å»ºï¼‰

```typescript
/**
 * Official Ad Domain Logic
 * Manages XunNi's own text/link ads
 */

export interface OfficialAd {
  id: number;
  ad_type: 'text' | 'link' | 'group' | 'channel';
  title: string;
  content: string;
  url?: string;
  target_entity_id?: string;
  reward_quota: number;
  is_enabled: number;
  start_date?: string;
  end_date?: string;
  max_views?: number;
  current_views: number;
  requires_verification: number;
  created_at: string;
  updated_at: string;
}

export interface OfficialAdView {
  id: number;
  telegram_id: string;
  ad_id: number;
  viewed_at: string;
  clicked: number;
  clicked_at?: string;
  verified: number;
  verified_at?: string;
  reward_granted: number;
  reward_granted_at?: string;
}

/**
 * Check if ad is currently active
 */
export function isAdActive(ad: OfficialAd): boolean {
  if (!ad.is_enabled) return false;
  
  const now = new Date();
  
  // Check start date
  if (ad.start_date) {
    const startDate = new Date(ad.start_date);
    if (now < startDate) return false;
  }
  
  // Check end date
  if (ad.end_date) {
    const endDate = new Date(ad.end_date);
    if (now > endDate) return false;
  }
  
  // Check max views
  if (ad.max_views && ad.current_views >= ad.max_views) {
    return false;
  }
  
  return true;
}

/**
 * Check if user has already viewed this ad
 */
export function hasUserViewedAd(
  views: OfficialAdView[],
  telegramId: string,
  adId: number
): boolean {
  return views.some(v => v.telegram_id === telegramId && v.ad_id === adId);
}

/**
 * Check if ad requires verification
 */
export function requiresVerification(ad: OfficialAd): boolean {
  return ad.requires_verification === 1 && 
         (ad.ad_type === 'group' || ad.ad_type === 'channel');
}

/**
 * Get ad button text based on type
 */
export function getAdButtonText(ad: OfficialAd): string {
  switch (ad.ad_type) {
    case 'text':
      return `âœ¨ é»æ“Šé ˜å– +${ad.reward_quota} é¡åº¦`;
    case 'link':
      return `ğŸ”— æŸ¥çœ‹è©³æƒ… (+${ad.reward_quota} é¡åº¦)`;
    case 'group':
      return `ğŸ‘¥ åŠ å…¥ç¾¤çµ„ (+${ad.reward_quota} é¡åº¦)`;
    case 'channel':
      return `ğŸ“¢ è¨‚é–±é »é“ (+${ad.reward_quota} é¡åº¦)`;
    default:
      return `é ˜å–çå‹µ`;
  }
}
```

---

### **æ•¸æ“šåº«æŸ¥è©¢**

#### **æ–‡ä»¶ï¼š`src/db/queries/official_ads.ts`**ï¼ˆæ–°å»ºï¼‰

```typescript
/**
 * Official Ads Database Queries
 */

import type { DatabaseClient } from '../client';
import type { OfficialAd, OfficialAdView } from '~/domain/official_ad';
import { isAdActive } from '~/domain/official_ad';

/**
 * Get all active official ads
 */
export async function getActiveOfficialAds(
  db: DatabaseClient
): Promise<OfficialAd[]> {
  const results = await db.d1
    .prepare(
      `SELECT * FROM official_ads 
       WHERE is_enabled = 1
       ORDER BY created_at DESC`
    )
    .all<OfficialAd>();
  
  // Filter by date and max views
  return (results.results || []).filter(ad => isAdActive(ad));
}

/**
 * Get official ad by ID
 */
export async function getOfficialAdById(
  db: DatabaseClient,
  adId: number
): Promise<OfficialAd | null> {
  const result = await db.d1
    .prepare(`SELECT * FROM official_ads WHERE id = ?`)
    .bind(adId)
    .first<OfficialAd>();
  
  return result || null;
}

/**
 * Get ads not viewed by user
 */
export async function getUnviewedAdsForUser(
  db: DatabaseClient,
  telegramId: string
): Promise<OfficialAd[]> {
  const results = await db.d1
    .prepare(
      `SELECT oa.* FROM official_ads oa
       LEFT JOIN official_ad_views oav 
         ON oa.id = oav.ad_id AND oav.telegram_id = ?
       WHERE oa.is_enabled = 1
         AND oav.id IS NULL
       ORDER BY oa.created_at DESC`
    )
    .bind(telegramId)
    .all<OfficialAd>();
  
  return (results.results || []).filter(ad => isAdActive(ad));
}

/**
 * Record ad view
 */
export async function recordAdView(
  db: DatabaseClient,
  telegramId: string,
  adId: number
): Promise<void> {
  await db.d1
    .prepare(
      `INSERT OR IGNORE INTO official_ad_views 
       (telegram_id, ad_id, viewed_at)
       VALUES (?, ?, CURRENT_TIMESTAMP)`
    )
    .bind(telegramId, adId)
    .run();
  
  // Increment view count
  await db.d1
    .prepare(
      `UPDATE official_ads 
       SET current_views = current_views + 1,
           updated_at = CURRENT_TIMESTAMP
       WHERE id = ?`
    )
    .bind(adId)
    .run();
}

/**
 * Record ad click and grant reward (for text/link types)
 */
export async function recordAdClick(
  db: DatabaseClient,
  telegramId: string,
  adId: number
): Promise<void> {
  await db.d1
    .prepare(
      `UPDATE official_ad_views 
       SET clicked = 1,
           clicked_at = CURRENT_TIMESTAMP,
           reward_granted = 1,
           reward_granted_at = CURRENT_TIMESTAMP
       WHERE telegram_id = ? AND ad_id = ?`
    )
    .bind(telegramId, adId)
    .run();
}

/**
 * Record verification and grant reward (for group/channel types)
 */
export async function recordAdVerification(
  db: DatabaseClient,
  telegramId: string,
  adId: number
): Promise<void> {
  await db.d1
    .prepare(
      `UPDATE official_ad_views 
       SET verified = 1,
           verified_at = CURRENT_TIMESTAMP,
           reward_granted = 1,
           reward_granted_at = CURRENT_TIMESTAMP
       WHERE telegram_id = ? AND ad_id = ?`
    )
    .bind(telegramId, adId)
    .run();
}

/**
 * Get ad view record
 */
export async function getAdView(
  db: DatabaseClient,
  telegramId: string,
  adId: number
): Promise<OfficialAdView | null> {
  const result = await db.d1
    .prepare(
      `SELECT * FROM official_ad_views 
       WHERE telegram_id = ? AND ad_id = ?`
    )
    .bind(telegramId, adId)
    .first<OfficialAdView>();
  
  return result || null;
}

/**
 * Create official ad (admin only)
 */
export async function createOfficialAd(
  db: DatabaseClient,
  ad: Omit<OfficialAd, 'id' | 'current_views' | 'created_at' | 'updated_at'>
): Promise<number> {
  const result = await db.d1
    .prepare(
      `INSERT INTO official_ads 
       (ad_type, title, content, url, target_entity_id, reward_quota, 
        is_enabled, start_date, end_date, max_views, requires_verification)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`
    )
    .bind(
      ad.ad_type,
      ad.title,
      ad.content,
      ad.url || null,
      ad.target_entity_id || null,
      ad.reward_quota,
      ad.is_enabled,
      ad.start_date || null,
      ad.end_date || null,
      ad.max_views || null,
      ad.requires_verification
    )
    .run();
  
  return result.meta.last_row_id as number;
}
```

---

### **å»£å‘Šè¼ªæ’­é‚è¼¯ï¼ˆå„ªå…ˆé¡¯ç¤ºå®˜æ–¹å»£å‘Šï¼‰**

#### **æ›´æ–°ï¼š`src/telegram/handlers/ad_reward.ts`**

åœ¨ç”¨æˆ¶é»æ“Šã€Œçœ‹å»£å‘Šå¢åŠ é¡åº¦ã€æ™‚ï¼Œå„ªå…ˆå±•ç¤ºå®˜æ–¹å»£å‘Šï¼ˆå¦‚æœæœ‰æœªçœ‹éçš„ï¼‰ï¼Œç„¶å¾Œæ‰æ˜¯ç¬¬ä¸‰æ–¹è¦–é »å»£å‘Šã€‚

```typescript
/**
 * Show ad options to user (official ads first, then third-party)
 */
export async function handleAdReward(
  telegram: TelegramService,
  db: DatabaseClient,
  chatId: number,
  telegramId: string
) {
  try {
    // Check if user is VIP
    const { getUser } = await import('~/db/queries/users');
    const user = await getUser(db, telegramId);
    
    if (!user) {
      await telegram.sendMessage(chatId, 'âŒ ç”¨æˆ¶ä¸å­˜åœ¨');
      return;
    }
    
    if (user.is_vip) {
      await telegram.sendMessage(
        chatId,
        'ğŸ’ VIP ç”¨æˆ¶ç„¡éœ€è§€çœ‹å»£å‘Š\n\næ‚¨å·²æ“æœ‰ 30 å€‹åŸºç¤é¡åº¦ + é‚€è«‹çå‹µï¼'
      );
      return;
    }
    
    // Get today's ad reward
    const { getOrCreateTodayAdReward } = await import('~/db/queries/ad_rewards');
    const adReward = await getOrCreateTodayAdReward(db, telegramId);
    
    // Get unviewed official ads
    const { getUnviewedAdsForUser } = await import('~/db/queries/official_ads');
    const officialAds = await getUnviewedAdsForUser(db, telegramId);
    
    // Calculate remaining third-party ads
    const { MAX_DAILY_ADS, getRemainingAds } = await import('~/domain/ad_reward');
    const remainingAds = getRemainingAds(adReward.ads_watched);
    
    // Build message
    let message = 'ğŸ“º **å¢åŠ é¡åº¦æ–¹å¼**\n\n';
    
    // Official ads section (priority)
    if (officialAds.length > 0) {
      message += 'ğŸ¯ **å®˜æ–¹æ¨å»£**ï¼ˆé»æ“Šå³çå‹µï¼Œæ°¸ä¹…é¡åº¦ï¼‰\n';
      officialAds.slice(0, 3).forEach((ad, index) => {
        const icon = {
          text: 'ğŸ“',
          link: 'ğŸ”—',
          group: 'ğŸ‘¥',
          channel: 'ğŸ“¢'
        }[ad.ad_type] || 'âœ¨';
        message += `${icon} ${ad.title} (+${ad.reward_quota} é¡åº¦)\n`;
      });
      message += '\n';
    }
    
    // Third-party ads section
    message += 'ğŸ“º **ç¬¬ä¸‰æ–¹å»£å‘Š**ï¼ˆè‡¨æ™‚é¡åº¦ï¼Œæ˜å¤©é‡ç½®ï¼‰\n';
    if (remainingAds > 0) {
      message += 
        `â€¢ æ¯çœ‹ä¸€å‰‡å»£å‘Š +1 é¡åº¦\n` +
        `â€¢ ä»Šæ—¥å‰©é¤˜ï¼š${remainingAds}/${MAX_DAILY_ADS} æ¬¡\n\n`;
    } else {
      message += `â€¢ ä»Šæ—¥å»£å‘Šå·²çœ‹å®Œï¼ˆ${MAX_DAILY_ADS}/${MAX_DAILY_ADS}ï¼‰\n\n`;
    }
    
    // Build inline keyboard
    const keyboard: InlineKeyboardButton[][] = [];
    
    // Add official ad buttons (max 3)
    const { getAdButtonText } = await import('~/domain/official_ad');
    officialAds.slice(0, 3).forEach(ad => {
      keyboard.push([{
        text: getAdButtonText(ad),
        callback_data: `official_ad:${ad.id}`
      }]);
    });
    
    // Add third-party ad button
    if (remainingAds > 0) {
      keyboard.push([{
        text: `ğŸ“º è§€çœ‹ç¬¬ä¸‰æ–¹å»£å‘Š (+1 é¡åº¦)`,
        url: `/ad?user=${telegramId}&token=${generateAdToken(telegramId)}`
      }]);
    }
    
    await telegram.sendMessage(chatId, message, {
      reply_markup: {
        inline_keyboard: keyboard
      }
    });
    
  } catch (error) {
    console.error('[handleAdReward] Error:', error);
    await telegram.sendMessage(chatId, 'âŒ ç²å–å»£å‘Šå¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦');
  }
}

/**
 * Handle official ad click
 */
export async function handleOfficialAdClick(
  telegram: TelegramService,
  db: DatabaseClient,
  chatId: number,
  telegramId: string,
  adId: number
) {
  try {
    // Get ad details
    const { getOfficialAdById } = await import('~/db/queries/official_ads');
    const ad = await getOfficialAdById(db, adId);
    
    if (!ad) {
      await telegram.answerCallbackQuery(chatId, 'âŒ å»£å‘Šä¸å­˜åœ¨');
      return;
    }
    
    // Check if already viewed
    const { getAdView } = await import('~/db/queries/official_ads');
    const view = await getAdView(db, telegramId, adId);
    
    if (view && view.reward_granted) {
      await telegram.answerCallbackQuery(chatId, 'âœ… æ‚¨å·²é ˜å–éæ­¤çå‹µ');
      return;
    }
    
    // Record view if first time
    if (!view) {
      const { recordAdView } = await import('~/db/queries/official_ads');
      await recordAdView(db, telegramId, adId);
    }
    
    // Handle different ad types
    const { requiresVerification } = await import('~/domain/official_ad');
    
    if (requiresVerification(ad)) {
      // Group/Channel with verification
      await handleVerificationAd(telegram, db, chatId, telegramId, ad);
    } else {
      // Text/Link - instant reward
      await handleInstantRewardAd(telegram, db, chatId, telegramId, ad);
    }
    
  } catch (error) {
    console.error('[handleOfficialAdClick] Error:', error);
    await telegram.answerCallbackQuery(chatId, 'âŒ è™•ç†å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦');
  }
}

/**
 * Handle instant reward ad (text/link)
 */
async function handleInstantRewardAd(
  telegram: TelegramService,
  db: DatabaseClient,
  chatId: number,
  telegramId: string,
  ad: OfficialAd
) {
  // Record click and grant reward
  const { recordAdClick } = await import('~/db/queries/official_ads');
  await recordAdClick(db, telegramId, ad.id);
  
  // Update user quota (add to permanent quota, not daily ad quota)
  const { updateUser, getUser } = await import('~/db/queries/users');
  const user = await getUser(db, telegramId);
  
  if (user) {
    // Add to invite_bonus (permanent quota)
    await updateUser(db, telegramId, {
      invite_bonus: user.invite_bonus + ad.reward_quota
    });
  }
  
  // Send message with link button if applicable
  let message = `âœ… **çå‹µå·²ç™¼æ”¾**\n\n`;
  message += `${ad.content}\n\n`;
  message += `ğŸ æ‚¨ç²å¾—äº† +${ad.reward_quota} é¡åº¦ï¼ˆæ°¸ä¹…ï¼‰`;
  
  const keyboard: InlineKeyboardButton[][] = [];
  
  if (ad.url) {
    keyboard.push([{
      text: ad.ad_type === 'link' ? 'ğŸ”— æŸ¥çœ‹è©³æƒ…' : 'ğŸ‘¥ åŠ å…¥',
      url: ad.url
    }]);
  }
  
  await telegram.sendMessage(chatId, message, {
    reply_markup: keyboard.length > 0 ? { inline_keyboard: keyboard } : undefined
  });
}

/**
 * Handle verification ad (group/channel)
 */
async function handleVerificationAd(
  telegram: TelegramService,
  db: DatabaseClient,
  chatId: number,
  telegramId: string,
  ad: OfficialAd
) {
  // Send message with join button
  let message = `ğŸ“¢ **${ad.title}**\n\n`;
  message += `${ad.content}\n\n`;
  message += `ğŸ åŠ å…¥å¾Œç²å¾— +${ad.reward_quota} é¡åº¦ï¼ˆæ°¸ä¹…ï¼‰\n`;
  message += `â³ åŠ å…¥å¾Œé»æ“Šã€Œé©—è­‰ã€æŒ‰éˆ•é ˜å–çå‹µ`;
  
  const keyboard: InlineKeyboardButton[][] = [
    [{
      text: ad.ad_type === 'group' ? 'ğŸ‘¥ åŠ å…¥ç¾¤çµ„' : 'ğŸ“¢ è¨‚é–±é »é“',
      url: ad.url!
    }],
    [{
      text: 'âœ… æˆ‘å·²åŠ å…¥ï¼Œé©—è­‰é ˜å–',
      callback_data: `verify_ad:${ad.id}`
    }]
  ];
  
  await telegram.sendMessage(chatId, message, {
    reply_markup: { inline_keyboard: keyboard }
  });
}

/**
 * Handle ad verification
 */
export async function handleAdVerification(
  telegram: TelegramService,
  db: DatabaseClient,
  chatId: number,
  telegramId: string,
  adId: number
) {
  try {
    // Get ad details
    const { getOfficialAdById } = await import('~/db/queries/official_ads');
    const ad = await getOfficialAdById(db, adId);
    
    if (!ad || !ad.target_entity_id) {
      await telegram.answerCallbackQuery(chatId, 'âŒ å»£å‘Šä¸å­˜åœ¨');
      return;
    }
    
    // Check if user is in group/channel
    const isMember = await telegram.checkUserMembership(
      ad.target_entity_id,
      telegramId
    );
    
    if (!isMember) {
      await telegram.answerCallbackQuery(
        chatId,
        'âŒ è«‹å…ˆåŠ å…¥ç¾¤çµ„/é »é“å¾Œå†é©—è­‰'
      );
      return;
    }
    
    // Record verification and grant reward
    const { recordAdVerification } = await import('~/db/queries/official_ads');
    await recordAdVerification(db, telegramId, adId);
    
    // Update user quota
    const { updateUser, getUser } = await import('~/db/queries/users');
    const user = await getUser(db, telegramId);
    
    if (user) {
      await updateUser(db, telegramId, {
        invite_bonus: user.invite_bonus + ad.reward_quota
      });
    }
    
    await telegram.sendMessage(
      chatId,
      `âœ… **é©—è­‰æˆåŠŸï¼**\n\n` +
      `ğŸ æ‚¨ç²å¾—äº† +${ad.reward_quota} é¡åº¦ï¼ˆæ°¸ä¹…ï¼‰\n` +
      `ğŸ’¬ æ„Ÿè¬åŠ å…¥æˆ‘å€‘çš„ç¤¾ç¾¤ï¼`
    );
    
  } catch (error) {
    console.error('[handleAdVerification] Error:', error);
    await telegram.answerCallbackQuery(chatId, 'âŒ é©—è­‰å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦');
  }
}
```

---

### **ç®¡ç†å‘½ä»¤**

#### **æ–‡ä»¶ï¼š`src/telegram/handlers/admin_official_ads.ts`**ï¼ˆæ–°å»ºï¼‰

```typescript
/**
 * Admin Official Ads Management
 * Commands: /create_ad, /list_ads, /disable_ad
 */

import type { TelegramService } from '~/services/telegram';
import type { DatabaseClient } from '~/db/client';
import type { OfficialAd } from '~/domain/official_ad';

/**
 * Create official ad
 * Usage: /create_ad <type> <title> | <content> | [url] | [reward]
 */
export async function handleCreateAd(
  telegram: TelegramService,
  db: DatabaseClient,
  chatId: number,
  telegramId: string,
  args: string
) {
  try {
    // Check admin permission
    const { isAdmin } = await import('~/domain/admin');
    if (!await isAdmin(db, telegramId)) {
      await telegram.sendMessage(chatId, 'âŒ ç„¡æ¬Šé™');
      return;
    }
    
    if (!args) {
      const message = 
        'ğŸ“ **å‰µå»ºå®˜æ–¹å»£å‘Š**\n\n' +
        'è«‹æŒ‰ä»¥ä¸‹æ ¼å¼ç™¼é€ï¼š\n\n' +
        '`/create_ad <é¡å‹> <æ¨™é¡Œ> | <å…§å®¹> | [URL] | [çå‹µé¡åº¦]`\n\n' +
        '**é¡å‹ï¼š**\n' +
        'â€¢ `text` - ç´”æ–‡å­—å…¬å‘Š\n' +
        'â€¢ `link` - éˆæ¥æ¨å»£\n' +
        'â€¢ `group` - ç¾¤çµ„é‚€è«‹\n' +
        'â€¢ `channel` - é »é“è¨‚é–±\n\n' +
        '**ç¤ºä¾‹ï¼š**\n' +
        '`/create_ad text æ–°åŠŸèƒ½ä¸Šç·š | æˆ‘å€‘æ¨å‡ºäº†å…¨æ–°çš„ VIP åŠŸèƒ½ï¼ | | 1`\n' +
        '`/create_ad link ä¸‹è¼‰ App | é»æ“Šä¸‹è¼‰æˆ‘å€‘çš„ Mini App | https://t.me/bot/app | 1`\n' +
        '`/create_ad group åŠ å…¥ç¾¤çµ„ | åŠ å…¥å®˜æ–¹ç¾¤çµ„äº¤æµ | https://t.me/group | 2`';
      
      await telegram.sendMessage(chatId, message);
      return;
    }
    
    // Parse arguments
    const parts = args.split('|').map(p => p.trim());
    const [typeAndTitle, content, url, reward] = parts;
    
    if (!typeAndTitle || !content) {
      await telegram.sendMessage(chatId, 'âŒ æ ¼å¼éŒ¯èª¤ï¼Œè«‹æä¾›é¡å‹ã€æ¨™é¡Œå’Œå…§å®¹');
      return;
    }
    
    const [type, ...titleParts] = typeAndTitle.split(' ');
    const title = titleParts.join(' ');
    
    if (!['text', 'link', 'group', 'channel'].includes(type)) {
      await telegram.sendMessage(chatId, 'âŒ ç„¡æ•ˆçš„å»£å‘Šé¡å‹');
      return;
    }
    
    // Create ad
    const { createOfficialAd } = await import('~/db/queries/official_ads');
    const adId = await createOfficialAd(db, {
      ad_type: type as 'text' | 'link' | 'group' | 'channel',
      title,
      content,
      url: url || undefined,
      target_entity_id: undefined,
      reward_quota: reward ? parseInt(reward) : 1,
      is_enabled: 1,
      requires_verification: 0
    });
    
    await telegram.sendMessage(
      chatId,
      `âœ… **å»£å‘Šå‰µå»ºæˆåŠŸ**\n\n` +
      `ID: ${adId}\n` +
      `é¡å‹: ${type}\n` +
      `æ¨™é¡Œ: ${title}\n` +
      `çå‹µ: +${reward || 1} é¡åº¦`
    );
    
  } catch (error) {
    console.error('[handleCreateAd] Error:', error);
    await telegram.sendMessage(chatId, 'âŒ å‰µå»ºå¤±æ•—');
  }
}

/**
 * List official ads
 * Usage: /list_ads
 */
export async function handleListAds(
  telegram: TelegramService,
  db: DatabaseClient,
  chatId: number,
  telegramId: string
) {
  try {
    // Check admin permission
    const { isAdmin } = await import('~/domain/admin');
    if (!await isAdmin(db, telegramId)) {
      await telegram.sendMessage(chatId, 'âŒ ç„¡æ¬Šé™');
      return;
    }
    
    // Get all ads
    const ads = await db.d1
      .prepare(`SELECT * FROM official_ads ORDER BY created_at DESC LIMIT 20`)
      .all<OfficialAd>();
    
    if (!ads.results || ads.results.length === 0) {
      await telegram.sendMessage(chatId, 'ğŸ“ å°šæœªå‰µå»ºä»»ä½•å®˜æ–¹å»£å‘Š');
      return;
    }
    
    let message = 'ğŸ“ **å®˜æ–¹å»£å‘Šåˆ—è¡¨**\n\n';
    
    ads.results.forEach((ad, index) => {
      const status = ad.is_enabled ? 'âœ… å•Ÿç”¨' : 'âŒ åœç”¨';
      const type = {
        text: 'ğŸ“ æ–‡å­—',
        link: 'ğŸ”— éˆæ¥',
        group: 'ğŸ‘¥ ç¾¤çµ„',
        channel: 'ğŸ“¢ é »é“'
      }[ad.ad_type] || ad.ad_type;
      
      message += 
        `**${index + 1}. ${ad.title}** ${status}\n` +
        `â€¢ ID: ${ad.id}\n` +
        `â€¢ é¡å‹: ${type}\n` +
        `â€¢ çå‹µ: +${ad.reward_quota} é¡åº¦\n` +
        `â€¢ è§€çœ‹: ${ad.current_views}${ad.max_views ? `/${ad.max_views}` : ''} æ¬¡\n`;
      
      if (ad.requires_verification) {
        message += `â€¢ éœ€è¦èªè­‰: âœ…\n`;
      }
      
      message += '\n';
    });
    
    message += '\nä½¿ç”¨ `/disable_ad <ID>` åœç”¨å»£å‘Š';
    
    await telegram.sendMessage(chatId, message);
    
  } catch (error) {
    console.error('[handleListAds] Error:', error);
    await telegram.sendMessage(chatId, 'âŒ ç²å–åˆ—è¡¨å¤±æ•—');
  }
}

/**
 * Disable official ad
 * Usage: /disable_ad <ad_id>
 */
export async function handleDisableAd(
  telegram: TelegramService,
  db: DatabaseClient,
  chatId: number,
  telegramId: string,
  adId: number
) {
  try {
    // Check admin permission
    const { isAdmin } = await import('~/domain/admin');
    if (!await isAdmin(db, telegramId)) {
      await telegram.sendMessage(chatId, 'âŒ ç„¡æ¬Šé™');
      return;
    }
    
    // Disable ad
    await db.d1
      .prepare(
        `UPDATE official_ads 
         SET is_enabled = 0, updated_at = CURRENT_TIMESTAMP
         WHERE id = ?`
      )
      .bind(adId)
      .run();
    
    await telegram.sendMessage(chatId, `âœ… å»£å‘Š #${adId} å·²åœç”¨`);
    
  } catch (error) {
    console.error('[handleDisableAd] Error:', error);
    await telegram.sendMessage(chatId, 'âŒ åœç”¨å¤±æ•—');
  }
}
```

---

### **Router æ›´æ–°**

#### **æ›´æ–°ï¼š`src/router.ts`**

```typescript
// Handle callback queries
if (update.callback_query) {
  const callbackData = update.callback_query.data;
  
  // Official ad click
  if (callbackData?.startsWith('official_ad:')) {
    const adId = parseInt(callbackData.split(':')[1]);
    const { handleOfficialAdClick } = await import('~/telegram/handlers/ad_reward');
    await handleOfficialAdClick(
      telegram,
      db,
      update.callback_query.message.chat.id,
      update.callback_query.from.id.toString(),
      adId
    );
    return new Response('OK');
  }
  
  // Ad verification
  if (callbackData?.startsWith('verify_ad:')) {
    const adId = parseInt(callbackData.split(':')[1]);
    const { handleAdVerification } = await import('~/telegram/handlers/ad_reward');
    await handleAdVerification(
      telegram,
      db,
      update.callback_query.message.chat.id,
      update.callback_query.from.id.toString(),
      adId
    );
    return new Response('OK');
  }
}

// Admin commands
if (text?.startsWith('/create_ad')) {
  const args = text.substring(11).trim();
  const { handleCreateAd } = await import('~/telegram/handlers/admin_official_ads');
  await handleCreateAd(telegram, db, chatId, telegramId, args);
  return new Response('OK');
}

if (text === '/list_ads') {
  const { handleListAds } = await import('~/telegram/handlers/admin_official_ads');
  await handleListAds(telegram, db, chatId, telegramId);
  return new Response('OK');
}

if (text?.startsWith('/disable_ad ')) {
  const adId = parseInt(text.split(' ')[1]);
  const { handleDisableAd } = await import('~/telegram/handlers/admin_official_ads');
  await handleDisableAd(telegram, db, chatId, telegramId, adId);
  return new Response('OK');
}
```

---

## âœ… **å®˜æ–¹å»£å‘Šç³»çµ±å¯¦ç¾æª¢æŸ¥æ¸…å–®**

### **Phase 1: æ•¸æ“šåº«**
- [ ] å‰µå»º Migration `0027_create_official_ads.sql`
- [ ] åŸ·è¡Œ Migration
- [ ] é©—è­‰è¡¨çµæ§‹

### **Phase 2: Domain & Queries**
- [ ] å‰µå»º `src/domain/official_ad.ts`
- [ ] å‰µå»º `src/db/queries/official_ads.ts`
- [ ] ç·¨å¯«å–®å…ƒæ¸¬è©¦

### **Phase 3: Handlers**
- [ ] æ›´æ–° `src/telegram/handlers/ad_reward.ts` æ”¯æŒå®˜æ–¹å»£å‘Š
- [ ] å‰µå»º `src/telegram/handlers/admin_official_ads.ts`
- [ ] å¯¦ç¾å»£å‘Šè¼ªæ’­é‚è¼¯ï¼ˆå®˜æ–¹å„ªå…ˆï¼‰

### **Phase 4: Router**
- [ ] æ›´æ–° `src/router.ts` æ·»åŠ  callback è™•ç†
- [ ] æ·»åŠ ç®¡ç†å‘½ä»¤è·¯ç”±

### **Phase 5: æ¸¬è©¦**
- [ ] æ¸¬è©¦æ–‡å­—å»£å‘Šï¼ˆé»æ“Šå³çå‹µï¼‰
- [ ] æ¸¬è©¦éˆæ¥å»£å‘Š
- [ ] æ¸¬è©¦ç¾¤çµ„é‚€è«‹ï¼ˆç„¡èªè­‰ï¼‰
- [ ] æ¸¬è©¦ç¾¤çµ„é‚€è«‹ï¼ˆéœ€èªè­‰ï¼‰
- [ ] æ¸¬è©¦é »é“è¨‚é–±ï¼ˆéœ€èªè­‰ï¼‰
- [ ] æ¸¬è©¦ä¸€æ¬¡æ€§æ¨é€é‚è¼¯
- [ ] æ¸¬è©¦ç®¡ç†å‘½ä»¤

### **Phase 6: éƒ¨ç½²**
- [ ] éƒ¨ç½²åˆ° Staging
- [ ] å‰µå»ºæ¸¬è©¦å»£å‘Š
- [ ] é©—è­‰åŠŸèƒ½æ­£å¸¸
- [ ] éƒ¨ç½²åˆ° Production

---

## ğŸ¯ **å®˜æ–¹å»£å‘Šç³»çµ±å„ªå‹¢**

### **1. éˆæ´»æ€§**
- âœ… æ”¯æŒå¤šç¨®å»£å‘Šé¡å‹ï¼ˆtext/link/group/channelï¼‰
- âœ… å¯è‡ªå®šç¾©çå‹µé¡åº¦ï¼ˆ1-10 é¡åº¦ï¼‰
- âœ… æ”¯æŒæ™‚é–“ç¯„åœé™åˆ¶ï¼ˆstart_date/end_dateï¼‰
- âœ… æ”¯æŒè§€çœ‹æ¬¡æ•¸é™åˆ¶ï¼ˆmax_viewsï¼‰

### **2. ç”¨æˆ¶é«”é©—**
- âœ… é»æ“Šå³çå‹µï¼ˆç„¡éœ€ç­‰å¾…è¦–é »ï¼‰
- âœ… ä¸€æ¬¡æ€§æ¨é€ï¼ˆä¸é‡è¤‡æ‰“æ“¾ï¼‰
- âœ… çå‹µæ°¸ä¹…ï¼ˆåŠ åˆ° invite_bonusï¼Œä¸æ˜¯è‡¨æ™‚é¡åº¦ï¼‰
- âœ… ä¸è¨ˆå…¥æ¯æ—¥ 20 æ¬¡é™åˆ¶

### **3. æ¨å»£æ•ˆæœ**
- âœ… ç›´æ¥æ¨å»£å®˜æ–¹å…§å®¹
- âœ… å¢åŠ ç¾¤çµ„/é »é“æˆå“¡
- âœ… æé«˜ç”¨æˆ¶åƒèˆ‡åº¦
- âœ… å¯è¿½è¹¤æ¨å»£æ•ˆæœï¼ˆè§€çœ‹æ¬¡æ•¸ã€é»æ“Šç‡ï¼‰

### **4. ç®¡ç†ä¾¿åˆ©**
- âœ… ç°¡å–®çš„ç®¡ç†å‘½ä»¤ï¼ˆ/create_ad, /list_ads, /disable_adï¼‰
- âœ… å¯¦æ™‚æŸ¥çœ‹çµ±è¨ˆæ•¸æ“š
- âœ… éš¨æ™‚å•Ÿç”¨/åœç”¨
- âœ… æ”¯æŒæœªä¾†æ“´å±•ï¼ˆèªè­‰ç³»çµ±ã€A/B æ¸¬è©¦ï¼‰

---

## ğŸ“Š **å»£å‘Šè¼ªæ’­ç­–ç•¥ç¸½çµ**

### **å„ªå…ˆç´šé †åº**
1. **å®˜æ–¹å»£å‘Š**ï¼ˆæœ€å„ªå…ˆï¼‰
   - é»æ“Šå³çå‹µ
   - æ°¸ä¹…é¡åº¦
   - ä¸€æ¬¡æ€§æ¨é€
   - ä¸è¨ˆå…¥é™åˆ¶

2. **ç¬¬ä¸‰æ–¹è¦–é »å»£å‘Š**ï¼ˆæ¬¡å„ªå…ˆï¼‰
   - éœ€è¦è§€çœ‹å®Œæ•´è¦–é »
   - è‡¨æ™‚é¡åº¦ï¼ˆæ˜å¤©é‡ç½®ï¼‰
   - æ¯å¤©æœ€å¤š 20 æ¬¡

### **ç”¨æˆ¶çœ‹åˆ°çš„é †åº**
```
ğŸ“º å¢åŠ é¡åº¦æ–¹å¼

ğŸ¯ å®˜æ–¹æ¨å»£ï¼ˆé»æ“Šå³çå‹µï¼Œæ°¸ä¹…é¡åº¦ï¼‰
ğŸ“ æ–°åŠŸèƒ½ä¸Šç·š (+1 é¡åº¦)
ğŸ”— ä¸‹è¼‰ Mini App (+1 é¡åº¦)
ğŸ‘¥ åŠ å…¥å®˜æ–¹ç¾¤çµ„ (+2 é¡åº¦)

ğŸ“º ç¬¬ä¸‰æ–¹å»£å‘Šï¼ˆè‡¨æ™‚é¡åº¦ï¼Œæ˜å¤©é‡ç½®ï¼‰
â€¢ æ¯çœ‹ä¸€å‰‡å»£å‘Š +1 é¡åº¦
â€¢ ä»Šæ—¥å‰©é¤˜ï¼š15/20 æ¬¡

[æŒ‰éˆ•: âœ¨ é»æ“Šé ˜å– +1 é¡åº¦]
[æŒ‰éˆ•: ğŸ”— æŸ¥çœ‹è©³æƒ… (+1 é¡åº¦)]
[æŒ‰éˆ•: ğŸ‘¥ åŠ å…¥ç¾¤çµ„ (+2 é¡åº¦)]
[æŒ‰éˆ•: ğŸ“º è§€çœ‹ç¬¬ä¸‰æ–¹å»£å‘Š (+1 é¡åº¦)]
```

---

**å®˜æ–¹å»£å‘Šç³»çµ±è¨­è¨ˆå®Œæˆï¼** ğŸ‰

**æœ€å¾Œæ›´æ–°**: 2025-01-18  
**ç‰ˆæœ¬**: 3.0ï¼ˆæ–°å¢å®˜æ–¹å»£å‘Šç³»çµ±ï¼‰  
**ä½œè€…**: XunNi Team



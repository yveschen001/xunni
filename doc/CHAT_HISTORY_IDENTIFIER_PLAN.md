# èŠå¤©è¨˜éŒ„å°è±¡æ¨™è­˜åŠŸèƒ½è¨ˆåŠƒ

**ç‹€æ…‹ï¼š** å¾…é–‹ç™¼  
**å„ªå…ˆç´šï¼š** é«˜  
**é è¨ˆå·¥æ™‚ï¼š** 3-4 å°æ™‚

---

## ğŸ“‹ åŠŸèƒ½æ¦‚è¿°

åœ¨èŠå¤©è¨˜éŒ„ä¸­ç‚ºæ¯å€‹å°è©±å°è±¡æ·»åŠ å”¯ä¸€çš„ `#` æ¨™è­˜ç¬¦ï¼Œæ–¹ä¾¿ç”¨æˆ¶è­˜åˆ¥å’ŒæŸ¥è©¢åŒä¸€å°è±¡çš„æ‰€æœ‰å°è©±è¨˜éŒ„ã€‚

---

## ğŸ¯ åŠŸèƒ½éœ€æ±‚

### 1. å°è±¡æ¨™è­˜ç¬¦è¨­è¨ˆ

**æ ¼å¼ï¼š** `#A`, `#B`, `#C`, ..., `#Z`, `#AA`, `#AB`, ...

**è¦å‰‡ï¼š**
- æ¯å€‹å°è©±å°è±¡åˆ†é…ä¸€å€‹å”¯ä¸€æ¨™è­˜ç¬¦
- æŒ‰ç…§å°è©±é–‹å§‹æ™‚é–“é †åºåˆ†é…
- åŒä¸€å°è±¡åœ¨æ‰€æœ‰å°è©±ä¸­ä½¿ç”¨ç›¸åŒæ¨™è­˜ç¬¦
- æ¨™è­˜ç¬¦åœ¨ç”¨æˆ¶ç¶­åº¦å”¯ä¸€ï¼ˆä¸åŒç”¨æˆ¶å¯ä»¥æœ‰ç›¸åŒæ¨™è­˜ç¬¦æŒ‡å‘ä¸åŒå°è±¡ï¼‰

**ç¤ºä¾‹ï¼š**
```
ç”¨æˆ¶ Alice çš„å°è©±å°è±¡ï¼š
- #A: Bobï¼ˆç¬¬ä¸€å€‹å°è©±å°è±¡ï¼‰
- #B: Charlieï¼ˆç¬¬äºŒå€‹å°è©±å°è±¡ï¼‰
- #C: Davidï¼ˆç¬¬ä¸‰å€‹å°è©±å°è±¡ï¼‰

ç”¨æˆ¶ Bob çš„å°è©±å°è±¡ï¼š
- #A: Aliceï¼ˆBob çš„ç¬¬ä¸€å€‹å°è©±å°è±¡ï¼‰
- #B: Eveï¼ˆBob çš„ç¬¬äºŒå€‹å°è©±å°è±¡ï¼‰
```

### 2. é¡¯ç¤ºä½ç½®

#### 2.1 èŠå¤©è¨˜éŒ„åˆ—è¡¨

```
ğŸ’¬ **ä½ çš„èŠå¤©è¨˜éŒ„**

ğŸ“¨ #A çš„å°è©±ï¼ˆ3 å‰‡è¨Šæ¯ï¼‰
æœ€å¾Œè¨Šæ¯ï¼šä½ å¥½ï¼Œå¾ˆé«˜èˆˆèªè­˜ä½ 
æ™‚é–“ï¼š2025-01-15 14:30

ğŸ“¨ #B çš„å°è©±ï¼ˆ5 å‰‡è¨Šæ¯ï¼‰
æœ€å¾Œè¨Šæ¯ï¼šä»Šå¤©å¤©æ°£çœŸå¥½
æ™‚é–“ï¼š2025-01-15 12:00

ğŸ“¨ #C çš„å°è©±ï¼ˆ1 å‰‡è¨Šæ¯ï¼‰
æœ€å¾Œè¨Šæ¯ï¼šè¬è¬ä½ çš„åˆ†äº«
æ™‚é–“ï¼š2025-01-14 18:45

[ğŸ” æœå°‹å°è©±] [ğŸ  è¿”å›ä¸»é¸å–®]
```

#### 2.2 å°è©±è©³æƒ…

```
ğŸ’¬ **èˆ‡ #A çš„å°è©±**

ğŸ“¨ 2025-01-15 10:00
å°æ–¹ï¼šä½ å¥½ï¼
ä½ ï¼šä½ å¥½ï¼Œå¾ˆé«˜èˆˆèªè­˜ä½ 

ğŸ“¨ 2025-01-15 12:30
ä½ ï¼šä»Šå¤©éå¾—æ€éº¼æ¨£ï¼Ÿ
å°æ–¹ï¼šå¾ˆå¥½ï¼Œè¬è¬ï¼

ğŸ“¨ 2025-01-15 14:30
å°æ–¹ï¼šä½ å‘¢ï¼Ÿ
ä½ ï¼šä¹Ÿä¸éŒ¯ï¼

[ğŸ’¬ ç¹¼çºŒå°è©± /reply] [ğŸ‘¤ æŸ¥çœ‹è³‡æ–™] [ğŸ  è¿”å›]
```

#### 2.3 æ”¶åˆ°æ–°è¨Šæ¯

```
ğŸ’¬ **æ”¶åˆ°æ–°è¨Šæ¯ï¼ˆä¾†è‡ª #Aï¼‰**

å°æ–¹èªªï¼š
ã€Œä½ å¥½ï¼Œä»Šå¤©å¤©æ°£çœŸå¥½ï¼ã€

ğŸ’¬ ç›´æ¥æŒ‰ /reply å›è¦†è¨Šæ¯èŠå¤©
ğŸ  è¿”å›ä¸»é¸å–®ï¼š/menu
```

### 3. æœå°‹åŠŸèƒ½

**å‘½ä»¤ï¼š** `/history #A` æˆ– `/history A`

**åŠŸèƒ½ï¼š**
- é¡¯ç¤ºèˆ‡ç‰¹å®šå°è±¡çš„æ‰€æœ‰å°è©±
- æ”¯æ´æ¨™è­˜ç¬¦æœå°‹ï¼ˆ`#A` æˆ– `A`ï¼‰
- é¡¯ç¤ºå°è©±çµ±è¨ˆï¼ˆè¨Šæ¯æ•¸ã€æœ€å¾Œè¨Šæ¯æ™‚é–“ï¼‰

**ç¤ºä¾‹ï¼š**
```
ğŸ” **æœå°‹çµæœï¼š#A çš„å°è©±**

ğŸ“Š **çµ±è¨ˆï¼š**
â€¢ ç¸½è¨Šæ¯æ•¸ï¼š15 å‰‡
â€¢ ä½ ç™¼é€ï¼š8 å‰‡
â€¢ å°æ–¹ç™¼é€ï¼š7 å‰‡
â€¢ å°è©±é–‹å§‹ï¼š2025-01-10 09:00
â€¢ æœ€å¾Œè¨Šæ¯ï¼š2025-01-15 14:30

ğŸ“¨ **æœ€è¿‘å°è©±ï¼š**
[é¡¯ç¤ºæœ€è¿‘ 5 å‰‡è¨Šæ¯]

[ğŸ’¬ ç¹¼çºŒå°è©±] [ğŸ‘¤ æŸ¥çœ‹è³‡æ–™] [ğŸ  è¿”å›]
```

---

## ğŸ› ï¸ æŠ€è¡“å¯¦ç¾

### 1. è³‡æ–™åº«è¨­è¨ˆ

#### æ–°å¢è¡¨ï¼šconversation_identifiers

```sql
CREATE TABLE IF NOT EXISTS conversation_identifiers (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_telegram_id TEXT NOT NULL,        -- ç”¨æˆ¶ ID
  partner_telegram_id TEXT NOT NULL,     -- å°è©±å°è±¡ ID
  identifier TEXT NOT NULL,              -- æ¨™è­˜ç¬¦ (A, B, C, ...)
  first_conversation_id INTEGER NOT NULL, -- ç¬¬ä¸€å€‹å°è©± ID
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(user_telegram_id, partner_telegram_id),
  UNIQUE(user_telegram_id, identifier),
  FOREIGN KEY (user_telegram_id) REFERENCES users(telegram_id),
  FOREIGN KEY (partner_telegram_id) REFERENCES users(telegram_id),
  FOREIGN KEY (first_conversation_id) REFERENCES conversations(id)
);

CREATE INDEX idx_conv_identifiers_user ON conversation_identifiers(user_telegram_id);
CREATE INDEX idx_conv_identifiers_partner ON conversation_identifiers(user_telegram_id, partner_telegram_id);
CREATE INDEX idx_conv_identifiers_id ON conversation_identifiers(user_telegram_id, identifier);
```

### 2. æ ¸å¿ƒå‡½æ•¸

```typescript
// src/domain/conversation_identifier.ts

export function generateNextIdentifier(currentIdentifiers: string[]): string {
  const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  
  if (currentIdentifiers.length === 0) {
    return 'A';
  }
  
  // æ‰¾åˆ°æœ€å¤§çš„æ¨™è­˜ç¬¦
  const maxIdentifier = currentIdentifiers.sort().pop()!;
  
  // è¨ˆç®—ä¸‹ä¸€å€‹æ¨™è­˜ç¬¦
  return incrementIdentifier(maxIdentifier);
}

function incrementIdentifier(identifier: string): string {
  const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  const chars = identifier.split('');
  
  // å¾å³åˆ°å·¦éå¢
  for (let i = chars.length - 1; i >= 0; i--) {
    const currentIndex = alphabet.indexOf(chars[i]);
    
    if (currentIndex < 25) {
      // å¯ä»¥ç›´æ¥éå¢
      chars[i] = alphabet[currentIndex + 1];
      return chars.join('');
    } else {
      // éœ€è¦é€²ä½
      chars[i] = 'A';
      if (i === 0) {
        // æœ€é«˜ä½é€²ä½ï¼Œéœ€è¦æ·»åŠ æ–°ä½
        return 'A' + chars.join('');
      }
    }
  }
  
  return chars.join('');
}

// æ¸¬è©¦
// A -> B -> C -> ... -> Z -> AA -> AB -> ... -> AZ -> BA -> ...
```

### 3. è³‡æ–™åº«æŸ¥è©¢

```typescript
// src/db/queries/conversation_identifiers.ts

export async function getOrCreateIdentifier(
  db: DatabaseClient,
  userTelegramId: string,
  partnerTelegramId: string,
  conversationId: number
): Promise<string> {
  // 1. æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
  const existing = await db.d1
    .prepare(
      'SELECT identifier FROM conversation_identifiers WHERE user_telegram_id = ? AND partner_telegram_id = ?'
    )
    .bind(userTelegramId, partnerTelegramId)
    .first<{ identifier: string }>();
  
  if (existing) {
    return existing.identifier;
  }
  
  // 2. ç”Ÿæˆæ–°æ¨™è­˜ç¬¦
  const allIdentifiers = await db.d1
    .prepare('SELECT identifier FROM conversation_identifiers WHERE user_telegram_id = ? ORDER BY identifier')
    .bind(userTelegramId)
    .all<{ identifier: string }>();
  
  const currentIdentifiers = allIdentifiers.results.map(r => r.identifier);
  const newIdentifier = generateNextIdentifier(currentIdentifiers);
  
  // 3. ä¿å­˜åˆ°è³‡æ–™åº«
  await db.d1
    .prepare(
      'INSERT INTO conversation_identifiers (user_telegram_id, partner_telegram_id, identifier, first_conversation_id) VALUES (?, ?, ?, ?)'
    )
    .bind(userTelegramId, partnerTelegramId, newIdentifier, conversationId)
    .run();
  
  return newIdentifier;
}

export async function getIdentifierByPartner(
  db: DatabaseClient,
  userTelegramId: string,
  partnerTelegramId: string
): Promise<string | null> {
  const result = await db.d1
    .prepare(
      'SELECT identifier FROM conversation_identifiers WHERE user_telegram_id = ? AND partner_telegram_id = ?'
    )
    .bind(userTelegramId, partnerTelegramId)
    .first<{ identifier: string }>();
  
  return result?.identifier || null;
}

export async function getPartnerByIdentifier(
  db: DatabaseClient,
  userTelegramId: string,
  identifier: string
): Promise<string | null> {
  const result = await db.d1
    .prepare(
      'SELECT partner_telegram_id FROM conversation_identifiers WHERE user_telegram_id = ? AND identifier = ?'
    )
    .bind(userTelegramId, identifier.toUpperCase())
    .first<{ partner_telegram_id: string }>();
  
  return result?.partner_telegram_id || null;
}

export async function getAllConversationsWithIdentifiers(
  db: DatabaseClient,
  userTelegramId: string
): Promise<Array<{
  identifier: string;
  partnerTelegramId: string;
  messageCount: number;
  lastMessageTime: string;
  lastMessagePreview: string;
}>> {
  // è¤‡é›œæŸ¥è©¢ï¼Œçµåˆ conversations å’Œ conversation_messages
  const query = `
    SELECT 
      ci.identifier,
      ci.partner_telegram_id,
      COUNT(cm.id) as message_count,
      MAX(cm.created_at) as last_message_time,
      (SELECT content FROM conversation_messages 
       WHERE conversation_id IN (
         SELECT id FROM conversations 
         WHERE (user1_telegram_id = ? AND user2_telegram_id = ci.partner_telegram_id)
            OR (user2_telegram_id = ? AND user1_telegram_id = ci.partner_telegram_id)
       )
       ORDER BY created_at DESC LIMIT 1
      ) as last_message_preview
    FROM conversation_identifiers ci
    LEFT JOIN conversations c ON (
      (c.user1_telegram_id = ? AND c.user2_telegram_id = ci.partner_telegram_id)
      OR (c.user2_telegram_id = ? AND c.user1_telegram_id = ci.partner_telegram_id)
    )
    LEFT JOIN conversation_messages cm ON cm.conversation_id = c.id
    WHERE ci.user_telegram_id = ?
    GROUP BY ci.identifier, ci.partner_telegram_id
    ORDER BY last_message_time DESC
  `;
  
  const { results } = await db.d1
    .prepare(query)
    .bind(userTelegramId, userTelegramId, userTelegramId, userTelegramId, userTelegramId)
    .all();
  
  return results as any;
}
```

### 4. Handler ä¿®æ”¹

#### ä¿®æ”¹ï¼šmessage_forward.ts

```typescript
// åœ¨ç™¼é€è¨Šæ¯æ™‚æ·»åŠ æ¨™è­˜ç¬¦
const identifier = await getOrCreateIdentifier(
  db,
  receiverTelegramId,
  senderTelegramId,
  conversationId
);

await telegram.sendMessage(
  receiverTelegramId,
  `ğŸ’¬ **æ”¶åˆ°æ–°è¨Šæ¯ï¼ˆä¾†è‡ª #${identifier}ï¼‰**\n\n` +
    `å°æ–¹èªªï¼š\nã€Œ${translatedContent}ã€\n\n` +
    `ğŸ’¬ ç›´æ¥æŒ‰ /reply å›è¦†è¨Šæ¯èŠå¤©\n` +
    `ğŸ  è¿”å›ä¸»é¸å–®ï¼š/menu`
);
```

#### æ–°å¢ï¼šhistory.ts

```typescript
// src/telegram/handlers/history.ts

export async function handleHistory(
  message: TelegramMessage,
  env: Env
): Promise<void> {
  const db = createDatabaseClient(env);
  const telegram = createTelegramService(env);
  const telegramId = message.from.id.toString();
  
  // è§£æå‘½ä»¤åƒæ•¸
  const args = message.text?.split(' ');
  const searchIdentifier = args?.[1]?.replace('#', '').toUpperCase();
  
  if (searchIdentifier) {
    // æœå°‹ç‰¹å®šå°è±¡çš„å°è©±
    await showConversationByIdentifier(db, telegram, telegramId, searchIdentifier);
  } else {
    // é¡¯ç¤ºæ‰€æœ‰å°è©±
    await showAllConversations(db, telegram, telegramId);
  }
}

async function showAllConversations(
  db: DatabaseClient,
  telegram: TelegramService,
  telegramId: string
): Promise<void> {
  const conversations = await getAllConversationsWithIdentifiers(db, telegramId);
  
  if (conversations.length === 0) {
    await telegram.sendMessage(
      telegramId,
      'ğŸ’¬ ä½ é‚„æ²’æœ‰ä»»ä½•å°è©±è¨˜éŒ„\n\n' +
        'å¿«å»ä¸Ÿç“¶å­èªè­˜æ–°æœ‹å‹å§ï¼ /throw'
    );
    return;
  }
  
  let message = 'ğŸ’¬ **ä½ çš„èŠå¤©è¨˜éŒ„**\n\n';
  
  for (const conv of conversations) {
    message += `ğŸ“¨ #${conv.identifier} çš„å°è©±ï¼ˆ${conv.messageCount} å‰‡è¨Šæ¯ï¼‰\n`;
    message += `æœ€å¾Œè¨Šæ¯ï¼š${conv.lastMessagePreview.substring(0, 30)}...\n`;
    message += `æ™‚é–“ï¼š${formatDate(conv.lastMessageTime)}\n\n`;
  }
  
  await telegram.sendMessageWithButtons(
    telegramId,
    message,
    [
      [{ text: 'ğŸ  è¿”å›ä¸»é¸å–®', callback_data: 'menu' }],
    ]
  );
}

async function showConversationByIdentifier(
  db: DatabaseClient,
  telegram: TelegramService,
  telegramId: string,
  identifier: string
): Promise<void> {
  // ç²å–å°è©±å°è±¡
  const partnerTelegramId = await getPartnerByIdentifier(db, telegramId, identifier);
  
  if (!partnerTelegramId) {
    await telegram.sendMessage(
      telegramId,
      `âŒ æ‰¾ä¸åˆ°æ¨™è­˜ç¬¦ #${identifier} çš„å°è©±\n\n` +
        'ä½¿ç”¨ /history æŸ¥çœ‹æ‰€æœ‰å°è©±'
    );
    return;
  }
  
  // ç²å–å°è©±è¨˜éŒ„
  const messages = await getConversationMessages(db, telegramId, partnerTelegramId);
  
  // é¡¯ç¤ºå°è©±
  let message = `ğŸ’¬ **èˆ‡ #${identifier} çš„å°è©±**\n\n`;
  message += `ğŸ“Š **çµ±è¨ˆï¼š**\n`;
  message += `â€¢ ç¸½è¨Šæ¯æ•¸ï¼š${messages.length} å‰‡\n\n`;
  
  // é¡¯ç¤ºæœ€è¿‘ 10 å‰‡è¨Šæ¯
  const recentMessages = messages.slice(-10);
  for (const msg of recentMessages) {
    const time = formatTime(msg.created_at);
    const sender = msg.sender_telegram_id === telegramId ? 'ä½ ' : 'å°æ–¹';
    message += `ğŸ“¨ ${time}\n${sender}ï¼š${msg.content}\n\n`;
  }
  
  await telegram.sendMessageWithButtons(
    telegramId,
    message,
    [
      [{ text: 'ğŸ’¬ ç¹¼çºŒå°è©±', callback_data: `reply_${partnerTelegramId}` }],
      [{ text: 'ğŸ  è¿”å›', callback_data: 'menu' }],
    ]
  );
}
```

---

## ğŸ¨ UI è¨­è¨ˆç´°ç¯€

### èŠå¤©è¨˜éŒ„åˆ—è¡¨

```
ğŸ’¬ **ä½ çš„èŠå¤©è¨˜éŒ„**

ğŸ“¨ #A çš„å°è©±ï¼ˆ15 å‰‡è¨Šæ¯ï¼‰
æœ€å¾Œè¨Šæ¯ï¼šä½ å¥½ï¼Œä»Šå¤©å¤©æ°£çœŸå¥½ï¼
æ™‚é–“ï¼š2025-01-15 14:30

ğŸ“¨ #B çš„å°è©±ï¼ˆ8 å‰‡è¨Šæ¯ï¼‰
æœ€å¾Œè¨Šæ¯ï¼šè¬è¬ä½ çš„åˆ†äº«
æ™‚é–“ï¼š2025-01-15 10:00

ğŸ“¨ #C çš„å°è©±ï¼ˆ3 å‰‡è¨Šæ¯ï¼‰
æœ€å¾Œè¨Šæ¯ï¼šå¾ˆé«˜èˆˆèªè­˜ä½ 
æ™‚é–“ï¼š2025-01-14 18:00

ğŸ’¡ ä½¿ç”¨ /history #A æŸ¥çœ‹èˆ‡ #A çš„å®Œæ•´å°è©±

[ğŸ  è¿”å›ä¸»é¸å–®]
```

### å°è©±è©³æƒ…

```
ğŸ’¬ **èˆ‡ #A çš„å°è©±**

ğŸ“Š **çµ±è¨ˆï¼š**
â€¢ ç¸½è¨Šæ¯æ•¸ï¼š15 å‰‡
â€¢ ä½ ç™¼é€ï¼š8 å‰‡
â€¢ å°æ–¹ç™¼é€ï¼š7 å‰‡
â€¢ å°è©±é–‹å§‹ï¼š2025-01-10 09:00
â€¢ æœ€å¾Œè¨Šæ¯ï¼š2025-01-15 14:30

ğŸ“¨ **æœ€è¿‘å°è©±ï¼š**

ğŸ“¨ 2025-01-15 10:00
å°æ–¹ï¼šä½ å¥½ï¼

ğŸ“¨ 2025-01-15 10:05
ä½ ï¼šä½ å¥½ï¼Œå¾ˆé«˜èˆˆèªè­˜ä½ 

ğŸ“¨ 2025-01-15 14:30
å°æ–¹ï¼šä»Šå¤©å¤©æ°£çœŸå¥½ï¼

[ğŸ’¬ ç¹¼çºŒå°è©±] [ğŸ‘¤ æŸ¥çœ‹è³‡æ–™] [ğŸ  è¿”å›]
```

---

## ğŸ§ª æ¸¬è©¦è¨ˆåŠƒ

### å–®å…ƒæ¸¬è©¦
- [ ] æ¸¬è©¦æ¨™è­˜ç¬¦ç”Ÿæˆé‚è¼¯ï¼ˆA -> B -> ... -> Z -> AAï¼‰
- [ ] æ¸¬è©¦æ¨™è­˜ç¬¦å”¯ä¸€æ€§
- [ ] æ¸¬è©¦æ¨™è­˜ç¬¦æŸ¥è©¢

### é›†æˆæ¸¬è©¦
- [ ] æ¸¬è©¦é¦–æ¬¡å°è©±å‰µå»ºæ¨™è­˜ç¬¦
- [ ] æ¸¬è©¦åŒä¸€å°è±¡ä½¿ç”¨ç›¸åŒæ¨™è­˜ç¬¦
- [ ] æ¸¬è©¦å¤šå€‹å°è±¡ä½¿ç”¨ä¸åŒæ¨™è­˜ç¬¦
- [ ] æ¸¬è©¦ `/history` å‘½ä»¤
- [ ] æ¸¬è©¦ `/history #A` æœå°‹

### æ‰‹å‹•æ¸¬è©¦
- [ ] èˆ‡å¤šå€‹ç”¨æˆ¶å°è©±ï¼Œé©—è­‰æ¨™è­˜ç¬¦åˆ†é…
- [ ] æŸ¥çœ‹èŠå¤©è¨˜éŒ„åˆ—è¡¨
- [ ] æœå°‹ç‰¹å®šå°è±¡çš„å°è©±
- [ ] é©—è­‰æ¨™è­˜ç¬¦åœ¨è¨Šæ¯ä¸­æ­£ç¢ºé¡¯ç¤º

---

## ğŸ“… é–‹ç™¼æ™‚ç¨‹

### Phase 1: è³‡æ–™åº«å’Œæ ¸å¿ƒé‚è¼¯ï¼ˆ1 å°æ™‚ï¼‰
- [ ] å‰µå»º migration
- [ ] å¯¦ç¾æ¨™è­˜ç¬¦ç”Ÿæˆé‚è¼¯
- [ ] å¯¦ç¾è³‡æ–™åº«æŸ¥è©¢å‡½æ•¸
- [ ] å–®å…ƒæ¸¬è©¦

### Phase 2: Handler ä¿®æ”¹ï¼ˆ1 å°æ™‚ï¼‰
- [ ] ä¿®æ”¹ message_forward.ts æ·»åŠ æ¨™è­˜ç¬¦
- [ ] å¯¦ç¾ /history å‘½ä»¤
- [ ] å¯¦ç¾æœå°‹åŠŸèƒ½

### Phase 3: UI å„ªåŒ–ï¼ˆ1 å°æ™‚ï¼‰
- [ ] å„ªåŒ–èŠå¤©è¨˜éŒ„åˆ—è¡¨é¡¯ç¤º
- [ ] å„ªåŒ–å°è©±è©³æƒ…é¡¯ç¤º
- [ ] æ·»åŠ çµ±è¨ˆè³‡è¨Š

### Phase 4: æ¸¬è©¦å’Œæ–‡æª”ï¼ˆ1 å°æ™‚ï¼‰
- [ ] å®Œæ•´æ¸¬è©¦
- [ ] æ›´æ–°æ–‡æª”
- [ ] éƒ¨ç½²é©—è­‰

---

## âœ… é©—æ”¶æ¨™æº–

- [ ] æ¯å€‹å°è©±å°è±¡æœ‰å”¯ä¸€æ¨™è­˜ç¬¦
- [ ] æ¨™è­˜ç¬¦æŒ‰é †åºåˆ†é…ï¼ˆA, B, C, ...ï¼‰
- [ ] åŒä¸€å°è±¡åœ¨æ‰€æœ‰å°è©±ä¸­ä½¿ç”¨ç›¸åŒæ¨™è­˜ç¬¦
- [ ] `/history` é¡¯ç¤ºæ‰€æœ‰å°è©±
- [ ] `/history #A` é¡¯ç¤ºç‰¹å®šå°è©±
- [ ] æ–°è¨Šæ¯é¡¯ç¤ºå°è±¡æ¨™è­˜ç¬¦
- [ ] èŠå¤©è¨˜éŒ„é¡¯ç¤ºçµ±è¨ˆè³‡è¨Š
- [ ] æ‰€æœ‰æ¸¬è©¦é€šé

---

**å»ºç«‹æ™‚é–“ï¼š** 2025-01-16  
**ç¶­è­·è€…ï¼š** é–‹ç™¼åœ˜éšŠ  
**ç‹€æ…‹ï¼š** å¾…é–‹ç™¼


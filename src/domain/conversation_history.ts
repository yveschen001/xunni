/**
 * Conversation History Domain Logic
 *
 * Pure functions for managing conversation history posts
 */

import { getZodiacDisplay } from '~/domain/zodiac';

// Maximum characters per history post (ç•™ 200 å­—ç¬¦ç·©è¡)
export const MAX_HISTORY_POST_CHARS = 3800;

/**
 * Format a message entry for history post
 */
export function formatMessageEntry(
  time: Date,
  direction: 'sent' | 'received',
  content: string,
  i18n?: any
): string {
  const timeStr = formatTime(time);
  const directionLabel =
    direction === 'sent'
      ? i18n?.t('conversationHistory.you') || 'ä½ '
      : i18n?.t('conversationHistory.other') || 'å°æ–¹';
  return `[${timeStr}] ${directionLabel}ï¼š${content}`;
}

/**
 * Format time as HH:MM
 */
function formatTime(date: Date): string {
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');
  return `${hours}:${minutes}`;
}

/**
 * Format date as YYYY-MM-DD HH:MM
 */
function formatDateTime(date: Date): string {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');
  return `${year}-${month}-${day} ${hours}:${minutes}`;
}

/**
 * Build history post content
 */
export function buildHistoryPostContent(
  identifier: string,
  postNumber: number,
  messages: string[],
  totalMessages: number,
  partnerInfo?: {
    maskedNickname: string;
    mbti: string;
    bloodType: string;
    zodiac: string;
    matchScore?: number;
  },
  isVip?: boolean,
  i18n?: any
): string {
  if (i18n) {
    let content = i18n.t('conversationHistory.title', { identifier, postNumber }) + '\n\n';

    // Add partner info at the top if provided
    if (partnerInfo) {
      // Build MBTI string: Code (Title)
      let mbtiDisplay = partnerInfo.mbti;
      const mbtiCode = partnerInfo.mbti; // Assuming partnerInfo.mbti contains the code (e.g., ESTJ)
      // Check if it's a valid code (basic check, or just try lookup)
      // Note: partnerInfo.mbti might already be localized "Not Set" if generated by handler without i18n context?
      // But typically it should be the code.
      // Let's try to lookup title.
      const mbtiTitle = i18n.t(`mbti.titles.${mbtiCode}`, { defaultValue: '' });
      if (mbtiTitle && mbtiTitle !== `mbti.titles.${mbtiCode}`) {
         mbtiDisplay = `${mbtiCode} (${mbtiTitle})`;
      }

      content += i18n.t('conversationHistory.partnerInfo') + '\n';
      content +=
        i18n.t('conversationHistory.nickname', { nickname: partnerInfo.maskedNickname }) + '\n';
      content += i18n.t('conversationHistory.mbti', { mbti: mbtiDisplay }) + '\n';
      content +=
        i18n.t('conversationHistory.bloodType', { bloodType: partnerInfo.bloodType }) + '\n';
      content += i18n.t('conversationHistory.zodiac', { zodiac: getZodiacDisplay(partnerInfo.zodiac, i18n) }) + '\n';
      if (partnerInfo.matchScore) {
        content +=
          i18n.t('conversationHistory.matchScore', { score: Math.round(partnerInfo.matchScore) }) +
          '\n';
      }
      content += '\n';
    }

    content += 'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n';
    content += messages.join('\n') + '\n\n';
    content += 'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n';
    content += i18n.t('conversationHistory.historyNote') + '\n';
    content += i18n.t('conversationHistory.totalMessages', { count: totalMessages }) + '\n';
    content +=
      i18n.t('conversationHistory.lastUpdated', { time: formatDateTime(new Date()) }) + '\n\n';
    content += i18n.t('conversationHistory.replyHint') + '\n';

    // Add VIP upgrade hint for free users
    if (isVip === false) {
      content += '\n' + i18n.t('conversationHistory.vipUnlockAvatar') + '\n';
      content += i18n.t('conversationHistory.vipLearnMore');
    }

    return content;
  }

  // Fallback to default Chinese (Deprecated/Legacy support)
  const fallbackTitle = `ğŸ’¬ èˆ‡ #${identifier} çš„å°è©±è¨˜éŒ„ï¼ˆç¬¬ ${postNumber} é ï¼‰\n\n`;
  const fallbackPartnerInfo = partnerInfo
    ? `ğŸ‘¤ å°æ–¹è³‡æ–™ï¼š\n` +
      `ğŸ“ æš±ç¨±ï¼š${partnerInfo.maskedNickname}\n` +
      `ğŸ§  MBTIï¼š${partnerInfo.mbti}\n` +
      `ğŸ©¸ è¡€å‹ï¼š${partnerInfo.bloodType}\n` +
      `â­ æ˜Ÿåº§ï¼š${partnerInfo.zodiac}\n` +
      (partnerInfo.matchScore ? `ğŸ’« é…å°åº¦ï¼š${Math.round(partnerInfo.matchScore)}åˆ†\n` : '') +
      `\n`
    : '';
  const fallbackSeparator = `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n`;
  const fallbackHistoryNote = `ğŸ’¡ é€™æ˜¯å°è©±çš„æ­·å²è¨˜éŒ„\n`;
  const fallbackTotalMessages = `ğŸ“Š ç¸½è¨Šæ¯æ•¸ï¼š${totalMessages} å‰‡\n`;
  const fallbackLastUpdated = `ğŸ“… æœ€å¾Œæ›´æ–°ï¼š${formatDateTime(new Date())}\n\n`;
  const fallbackReplyHint = `ğŸ’¬ ç›´æ¥æŒ‰ /reply å›è¦†è¨Šæ¯èŠå¤©\n`;
  const fallbackVipUnlock =
    isVip === false ? `\nğŸ”’ å‡ç´š VIP è§£é–å°æ–¹æ¸…æ™°é ­åƒ\nğŸ’ ä½¿ç”¨ /vip äº†è§£æ›´å¤š` : '';

  return (
    fallbackTitle +
    fallbackPartnerInfo +
    fallbackSeparator +
    messages.join('\n') +
    '\n\n' +
    fallbackSeparator +
    fallbackHistoryNote +
    fallbackTotalMessages +
    fallbackLastUpdated +
    fallbackReplyHint +
    fallbackVipUnlock
  );
}

/**
 * Build new message post content
 */
export function buildNewMessagePostContent(
  identifier: string,
  messageContent: string,
  messageTime: Date,
  _conversationId: number,
  partnerInfo?: {
    maskedNickname: string;
    mbti: string;
    bloodType: string;
    zodiac: string;
    matchScore?: number;
  },
  i18n?: any,
  originalContent?: string
): string {
  if (i18n) {
    // Header: ğŸ“© ä¾†è‡ª {Nickname} çš„æ–°è¨Šæ¯ï¼š
    let content = i18n.t('conversationHistory.newMessageFrom', { 
      nickname: partnerInfo?.maskedNickname || identifier 
    }) + '\n\n';

    // Top Info: MBTI, Zodiac
    if (partnerInfo) {
      // Build MBTI string: Code (Title)
      let mbtiDisplay = partnerInfo.mbti;
      const mbtiCode = partnerInfo.mbti;
      // Try to lookup title
      const mbtiTitle = i18n.t(`mbti.titles.${mbtiCode}`, { defaultValue: '' });
      if (mbtiTitle && mbtiTitle !== `mbti.titles.${mbtiCode}`) {
         mbtiDisplay = `${mbtiCode} (${mbtiTitle})`;
      }

      content += i18n.t('conversationHistory.mbti', { mbti: mbtiDisplay }) + '\n';
      content += i18n.t('conversationHistory.zodiac', { zodiac: getZodiacDisplay(partnerInfo.zodiac, i18n) }) + '\n\n';
    }

    content += 'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n';

    // Content Area: Original + Translated
    if (originalContent && originalContent !== messageContent) {
      content += `${i18n.t('conversationHistory.originalContent')}\n${originalContent}\n\n`;
      content += `${i18n.t('conversationHistory.translatedContent')}\n${messageContent}\n`;
    } else {
      content += `${messageContent}\n`;
    }
    
    content += 'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n';

    // Footer / Hints (Buttons handled by service)
    return content;
  }

  // Fallback to default Chinese (Legacy)
  const nickname = partnerInfo?.maskedNickname || `#${identifier}`;
  const header = `ğŸ“© ä¾†è‡ª ${nickname} çš„æ–°è¨Šæ¯ï¼š\n\n`;
  
  let info = '';
  if (partnerInfo) {
    info += `ğŸ§  MBTIï¼š${partnerInfo.mbti}\n`;
    info += `â­ æ˜Ÿåº§ï¼š${partnerInfo.zodiac}\n\n`;
  }

  let body = 'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n';
  if (originalContent && originalContent !== messageContent) {
    body += `[åŸæ–‡]\n${originalContent}\n\n`;
    body += `[ç¿»è­¯]\n${messageContent}\n`;
  } else {
    body += `${messageContent}\n`;
  }
  body += 'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n';

  return header + info + body;
}

/**
 * Check if adding a new message would exceed the character limit
 */
export function wouldExceedLimit(currentContent: string, newMessage: string): boolean {
  const newLength = currentContent.length + newMessage.length + 1; // +1 for newline
  return newLength > MAX_HISTORY_POST_CHARS;
}

/**
 * Extract messages array from history post content
 */
export function extractMessages(content: string): string[] {
  const lines = content.split('\n');
  const messages: string[] = [];
  let inMessageSection = false;

  for (const line of lines) {
    if (line.includes('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”')) {
      if (!inMessageSection) {
        inMessageSection = true;
        continue;
      } else {
        break;
      }
    }

    if (inMessageSection && line.trim()) {
      messages.push(line);
    }
  }

  return messages;
}
